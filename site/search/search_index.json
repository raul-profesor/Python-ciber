{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Apuntes de Python para ciberseguridad.","title":"Home"},{"location":"SQLi/","text":"Vamos a escribir un script que detecte la forma m\u00e1s simple de inyecci\u00f3n SQL a modo de prueba de concepto. Probar\u00e1 a a\u00f1adir una comilla o dobles comillas en la URL y parsear la respuesta en busca de alg\u00fan error de base de datos, lo cual nos permite deducir que puede haber una potencial vulnerabilidad SQLi. As\u00ed las cosas, sigamos una serie de pasos para construir por partes nuestro script. Lo primero ser\u00eda iniciar nuestro entorno virtual e instalar ah\u00ed las dependencias que necesitaremos si es que no las ten\u00edamos todav\u00eda: pipenv shell pipenv install requests bs4 Ahora, debemos importar los m\u00f3dulos que vamos a necesitar en nuestro script: import requests # import re # uncomment this for DVWA from bs4 import BeautifulSoup as bs from urllib.parse import urljoin from pprint import pprint s = requests . Session () s . headers [ \"User-Agent\" ] = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36\" requests para realizar las peticiones HTTP BeautifulSoup para parsear el contenido de las p\u00e1ginas web urllib.parse para dividir las URLs en fragmentos y urljoin permite construir URLs pprint para imprimir datos de forma \"bonita\" Tambi\u00e9n inicializamos la sesi\u00f3n de requests y establecemos el user-agent del \"navegador\". Puesto que la inyecci\u00f3n SQL se basa en las entradas o inputs del usuario, necesitaremos extraer primero los formularios de la web. def get_all_forms ( url ): # (1) soup = bs ( s . get ( url ) . content , \"html.parser\" ) return soup . find_all ( \"form\" ) def get_form_details ( form ): # (2) details = {} try : # (3) action = form . attrs . get ( \"action\" ) . lower () except : action = None method = form . attrs . get ( \"method\" ) . lower () # (4) inputs = [] # (5) for input_tag in form . find_all ( \"input\" ): input_type = input_tag . attrs . get ( \"type\" , \"text\" ) input_name = input_tag . attrs . get ( \"name\" ) input_value = input_tag . attrs . get ( \"value\" , \"\" ) inputs . append ({ \"type\" : input_type , \"name\" : input_name , \"value\" : input_value }) details [ \"action\" ] = action # (6) details [ \"method\" ] = method details [ \"inputs\" ] = inputs return details Dada una 'url'. devuelve todos los formularios que contiene el c\u00f3digo HTML Esta funci\u00f3n extrae toda la posible informaci\u00f3n \u00fatil de un formulario HTML Se extrae el atributo form action de la URL objetivo Obtenemos el m\u00e9todo HTTP utilizado por el formulario (POST, GET ...) Se obtienen todos los detalles de los datos de entrada, tales como el tipo y el nombre Guardamos todos los resultados en un diccionario get_all_forms() utiliza BeautifulSoup para extraer todas las etiquetas/tags del c\u00f3digo HTML y devolerlas en forma de lista, mientras que la funci\u00f3n get_form_detgails() recibe una etiqueta \u00fanica del formulario como argumento y parsea la informaci\u00f3n \u00fatil del mismo. A continuaci\u00f3n definiremos una funci\u00f3n que nos dir\u00e1 si una p\u00e1gina contiene errores SQL, lo cual nos ser\u00e1 \u00fatil para comprobar si existe una vulnerabilidad del tipo SQL injection. def is_vulnerable ( response ): # (1) errors = { # MySQL \"you have an error in your sql syntax;\" , \"warning: mysql\" , # SQL Server \"unclosed quotation mark after the character string\" , # Oracle \"quoted string not properly terminated\" , } for error in errors : # Si se encuentra algunos de estos errores, devuelve True if error in response . content . decode () . lower (): return True # No se ha detectado error return False Una simple funci\u00f3n booleana que determina si una p\u00e1gina es vulnerable a un SQL injection analizando su respuesta Obviamente no podemos definir errores para todos los servidores de bases de datos. Para abarcar el m\u00e1ximo n\u00famero de posibilidades de tipos de error, deber\u00edamos hacer uso de las expresiones regulares . def scan_sql_injection ( url ): # probar en la URL for c in \" \\\" '\" : # a\u00f1adir comillas o dobles comillas a la URL new_url = f \" { url }{ c } \" print ( \"[!] Trying\" , new_url ) # \"fabricamos\" la petici\u00f3n HTTP res = s . get ( new_url ) if is_vulnerable ( res ): #(1) print ( \"[+] SQL Injection vulnerability detected, link:\" , new_url ) return # probamos los fomularios HTML forms = get_all_forms ( url ) print ( f \"[+] Detected { len ( forms ) } forms on { url } .\" ) for form in forms : form_details = get_form_details ( form ) for c in \" \\\" '\" : # los datos del cuerpo de la petici\u00f3n que queremos enviar data = {} for input_tag in form_details [ \"inputs\" ]: if input_tag [ \"value\" ] or input_tag [ \"type\" ] == \"hidden\" : # (2) try : data [ input_tag [ \"name\" ]] = input_tag [ \"value\" ] + c except : pass elif input_tag [ \"type\" ] != \"submit\" : #todos los tipos excepto *submit*, usando datos basura como #caract\u00e9res especiales data [ input_tag [ \"name\" ]] = f \"test { c } \" url = urljoin ( url , form_details [ \"action\" ]) # (3) if form_details [ \"method\" ] == \"post\" : res = s . post ( url , data = data ) elif form_details [ \"method\" ] == \"get\" : res = s . get ( url , params = data ) # comprobar si la p\u00e1gina resultante es vulnerable if is_vulnerable ( res ): print ( \"[+] SQL Injection vulnerability detected, link:\" , url ) print ( \"[+] Form:\" ) pprint ( form_details ) break Se ha detectado un SQLi en la misma URL, no es necesario proceder m\u00e1s all\u00e1 para extraer formularios y enviarlos Cualquier input del formulario que tiene alg\u00fan valor u oculto, s\u00f3lo para usarlo en el cuerpo de la petici\u00f3n Se junta (join) la URL con el action (la URL de la petici\u00f3n del formulario) Antes de extraer los formularios y enviarlos, la funci\u00f3n de arriba comprueba primero si hay vulnerabilidad en la misma URL. Esto lo hace simplemente a\u00f1adiendo una comilla ' a la URL. Tras ello se utiliza la biblioteca requests para realizar la petici\u00f3n y se compreba si el contenido de la respuesta contiene los errores que estamos buscando. A continuaci\u00f3n, \"parseamos\" los formularios y hacemos \"submit\" de cada uno de los que hemos encontrado a\u00f1adiendo las comillas. As\u00ed pues, el main de nuestro script queda as\u00ed: if __name__ == \"__main__\" : import sys url = sys . argv [ 1 ] scan_sql_injection ( url ) Referencias Code for How to Build a SQL Injection Scanner in Python Tutorial","title":"Busquemos inyecciones SQL"},{"location":"SQLi/#referencias","text":"Code for How to Build a SQL Injection Scanner in Python Tutorial","title":"Referencias"},{"location":"beauty/","text":"Beautiful Soup Web scraping Internet es una fuente de datos absolutamente masiva, datos a los que podemos acceder mediante el web scraping y Python. De hecho, el web scraping es a menudo la \u00fanica forma de acceder a los datos. Hay mucha informaci\u00f3n ah\u00ed fuera que no est\u00e1 disponible mediante c\u00f3modas exportaciones CSV o APIs f\u00e1ciles de conectar. Adem\u00e1s, los propios sitios web son a menudo valiosas fuentes de datos. Pensemos, por ejemplo, en el tipo de an\u00e1lisis que se podr\u00eda hacer si pudieramos descargar todos los mensajes de un foro web. Para acceder a este tipo de conjuntos de datos en la p\u00e1gina, tendremos que utilizar el web scraping. Fundamentos del web scraping Algunos sitios web ofrecen conjuntos de datos que se pueden descargar en formato CSV, o que son accesibles a trav\u00e9s de una interfaz de programaci\u00f3n de aplicaciones (API) . Pero muchos sitios web con datos \u00fatiles no ofrecen este tipo de opciones. Veamos, por ejemplo, el caso del sitio web del Servicio Meteorol\u00f3gico Nacional de EEUU. Contiene previsiones meteorol\u00f3gicas actualizadas para todos los lugares de Estados Unidos, pero esos datos meteorol\u00f3gicos no son accesibles en formato CSV ni a trav\u00e9s de la API. Hay que verlos en el propio sitio del NWS: Si quisi\u00e9ramos analizar estos datos, o descargarlos para utilizarlos en alguna otra aplicaci\u00f3n, no querr\u00edamos copiar y pegar todo a mano. El \"web scraping\" es una t\u00e9cnica que nos permite utilizar la programaci\u00f3n para hacer el trabajo pesado. Vamos a escribir un c\u00f3digo que busque en el sitio del NWS, coja s\u00f3lo los datos con los que queremos trabajar y los proporcione en el formato que necesitamos. Cuando hacemos scraping de la web, escribimos un c\u00f3digo que env\u00eda una petici\u00f3n al servidor que aloja la p\u00e1gina que hemos especificado. El servidor devolver\u00e1 el c\u00f3digo fuente - HTML, principalmente - de la p\u00e1gina (o p\u00e1ginas) que hemos solicitado. Hasta aqu\u00ed, estamos haciendo esencialmente lo mismo que hace un navegador web: enviar una petici\u00f3n al servidor con una URL espec\u00edfica y pedirle que nos devuelva el c\u00f3digo de esa p\u00e1gina. Pero a diferencia de un navegador web, nuestro c\u00f3digo de web scraping no interpretar\u00e1 el c\u00f3digo fuente de la p\u00e1gina y la mostrar\u00e1 visualmente. En su lugar, escribiremos un c\u00f3digo personalizado que filtrar\u00e1 dicho c\u00f3digo fuente en busca de los elementos concretos que hayamos especificado y extraer\u00e1 el contenido que le hayamos indicado. Por ejemplo, si quisi\u00e9ramos obtener todos los datos del interior de una tabla que se muestra en una p\u00e1gina web, nuestro c\u00f3digo se escribir\u00eda para seguir estos pasos en secuencia: Solicitar al servidor el contenido (c\u00f3digo fuente) de una URL espec\u00edfica Descargar el contenido devuelto Identificar los elementos de la p\u00e1gina que forman parte de la tabla que queremos Extraer y (si es necesario) reformatear esos elementos en un conjunto de datos que podamos analizar o utilizar de la forma que queramos. Si todo esto suena muy complicado, no hay de qu\u00e9 preocuparse, Python y Beautiful Soup tienen funciones integradas dise\u00f1adas para que esto sea relativamente sencillo. Una cosa que es importante tener en cuenta: desde la perspectiva de un servidor, solicitar una p\u00e1gina a trav\u00e9s de web scraping es lo mismo que cargarla en un navegador web. Cuando usamos c\u00f3digo para enviar estas peticiones, podemos estar \"cargando\" p\u00e1ginas mucho m\u00e1s r\u00e1pido que un usuario normal, y por tanto consumiendo r\u00e1pidamente los recursos del servidor del propietario del sitio web. \u00bfEs legal el Web Scraping? Desafortunadamente, no hay una respuesta clara en este aspecto. Algunos sitios web permiten expl\u00edcitamente el web scraping mientras que otros lo proh\u00edben expl\u00edcitamente. Muchos sitios web no ofrecen ninguna orientaci\u00f3n clara en un sentido u otro. Antes de hacer scraping de cualquier sitio web, debemos buscar una p\u00e1gina de t\u00e9rminos y condiciones para ver si hay normas expl\u00edcitas sobre el scraping. Si las hay, debemos cumplirlas. Si no las hay, se trata m\u00e1s bien de una cuesti\u00f3n de criterio. Sin embargo, hay que recordar que el scraping consume recursos del servidor del sitio web anfitri\u00f3n. Si s\u00f3lo hacemos scraping de una p\u00e1gina una vez, eso no va a causar un problema. Pero si nuestro c\u00f3digo est\u00e1 haciendo scraping de 1.000 p\u00e1ginas una vez cada diez minutos, eso r\u00e1pidamente podr\u00eda convertirse en un problema de costes para el propietario del sitio web. Por lo tanto, adem\u00e1s de seguir todas y cada una de las reglas expl\u00edcitas sobre el web scraping publicadas en el sitio, tambi\u00e9n es una buena idea seguir una serie de buenas pr\u00e1cticas recomendadas: Nunca hacer scraping con m\u00e1s frecuencia de la necesaria. Considerar la posibilidad de almacenar en cach\u00e9 el contenido que se obtenga procedente el scraping para que s\u00f3lo se descargue una vez. Incorpora pausas en tu c\u00f3digo utilizando funciones como time.sleep() para no abrumar a los servidores con demasiadas peticiones demasiado r\u00e1pido. En el ejemplo que nos ocupa, los datos del NWS son de dominio p\u00fablico y sus condiciones no proh\u00edben el scraping de la web, por lo que estamos en condiciones de proceder. Componentes de una p\u00e1gina web Antes de empezar a escribir c\u00f3digo, necesitamos entender un poco acerca de la estructura de una p\u00e1gina web ya que es lo que utilizaremos los datos deseados cuando hagamos scraping. Cuando visitamos un sitio web, nuesro navegador hace una petici\u00f3n a un servidor web. Esta petici\u00f3n ser\u00e1 de tipo GET puesto que estamos obteniendo ficheros del servidor. El servidor env\u00eda de vuelta al navegador los ficheros que le indican c\u00f3mo tiene que renderizar la p\u00e1gina para el usuario. Estos archivos t\u00edpicamente incluir\u00e1n: HTML: el contenido principal de la p\u00e1gina CSS: usado para a\u00f1adir estilos a las p\u00e1ginas y mejorar su aspecto JS: Javascript a\u00f1ade interactividad a la p\u00e1gina web. Im\u00e1genes: Para ser mostradas en el sitio Como hemos dicho ya, tras recibir los archivos, el navegador renderiza la p\u00e1gina y la muestra. A la hora de llevar a cabo el scrapig, estamos interesados en el contenido principal de la web as\u00ed que miraremos principalmente el c\u00f3digo HTML. HTML HTML es el lenguaje en el que est\u00e1n creados los sitios web. No se tata de un lenguaje de programaci\u00f3n como pueda serlo Python. Es un lenguaje de marcado que le dice al navegador como mostrar contenido. HTML tiene varias que son similiares a lo que se pudiera hacer con un procesador de textos (negrita, p\u00e1rrafos...). Hagamos un rapid\u00edsimo repaso de HTML. HTML est\u00e1 formado por elementos llamados tags o etiquetas . El m\u00e1s b\u00e1sico es <html> y es el que le indica al navegador que todo lo que vaya dentro de \u00e9l es HTML. As\u00ed pues, el documento HTML m\u00e1s simple ser\u00eda: < html > </ html > No hemos a\u00f1adido contenido a nuestra p\u00e1gina todav\u00eda as\u00ed que este documento HTML no mostrar\u00eda nada en un navegador. Podemos poner m\u00e1s etiquetas dentro de las etiquetas html : < html > < head > </ head > < body > </ body > </ html > El contenido principal del sitio web lo podremos encontrar dnetro de las etiquetas body . La etiqueta head contiene informaci\u00f3n acerca dle t\u00edtulo de la p\u00e1gina as\u00ed como otro tipo de informaci\u00f3n no \u00fatil para el web scraping. A\u00f1adamos ahora un p\u00e1rrafo dentro del body con su correspondiente etiqueta p : < html > < head > </ head > < body > < p > Primer p\u00e1rrafo </ p > < p > Segundo p\u00e1rrafo </ p > </ body > </ html > Podemos adem\u00e1s a\u00f1adir propiedades a las etiquetas HML que cambien su comportamiento. A\u00f1adamos ahora hiperenlaces con la etiqueta a : < html > < head > </ head > < body > < p > Primer p\u00e1rrafo < a href = \"https://www.dataquest.io\" > Learn Data Science Online </ a > </ p > < p > Segundo p\u00e1rrafo < a href = \"https://www.python.org\" > Python </ a > </ p > </ body > </ html > Que se ver\u00e1 as\u00ed: En el ejemplo anterio la etiqueta a indica que se trata de un link y la propiedad href determina a donde apunta ese link. Otras etiquetas comunes son: div: indica una divisi\u00f3n o \u00e1rea de la p\u00e1gina b: texto en negrita i: texto en cursiva table: crea una tabla form: crea un formulario Aqu\u00ed pod\u00e9is encontrar la lista completa de tags o etiquetas. Para acabar con el apartado dedicado a HTML, debemos hablar de las propiedades class y id . Estas propiedade especiales proporciona nombres a los elementos HTML, haciendo as\u00ed m\u00e1s f\u00e1cil interactuar con ellos a la hora de hacer scraping. Un elemento puede tener multiples clases y una clase puede ser compartida entre elementos. Cada elemento s\u00f3lo puede tener un \u00fanico id y un id s\u00f3lo puede usarse una vez por p\u00e1gina. Estos class y id son opcinoales y no todos los elementos los tendr\u00e1n. Sobre el ejemplo anterior: < html > < head > </ head > < body > < p class = \"bold-paragraph\" > Primer p\u00e1rrafo < a href = \"https://www.dataquest.io\" id = \"learn-link\" > Learn Data Science Online </ a > </ p > < p class = \"bold-paragraph extra-large\" > Segundo p\u00e1rrafo < a href = \"https://www.python.org\" class = \"extra-large\" > Python </ a > </ p > </ body > </ html > Estas propiedades no modifican la forma en que se ve la p\u00e1gina en el navegador. Parseando p\u00e1ginas con BeatifulSoup El parsing no es m\u00e1s que un an\u00e1lisis sint\u00e1ctico, como pod\u00e9is leer aqu\u00ed Supongamos que descargamos la siguiente p\u00e1gina usando la biblioteca Requests que ya hemos visto: import requests page = requests . get ( \"https://dataquestio.github.io/web-scraping-pages/simple.html\" ) page Podemos utilizar la biblioteca BeautifulSoup para parsear este documento y extraer el texto de la etiqueta p . Lo primero que deberemos hacer, como siempre, es instalar BeautifulSoup. Podemos hacerlo en nuestro entorno virtual: O de forma general en nuestra m\u00e1quina: pipenv shell pipenv install beautifulsoup4 Ahora, en el entorno interactivo de python, podemos proceder: Lo que hemos hecho ha sido importar la biblioteca y crear una instancia de la clase BeautifulSoup para parsear nuestro documento. Tras ello, hemos mostrado por pantall el contenido de la p\u00e1gina de una forma un poco m\u00e1s bonita utilizando el m\u00e9todo prettify del objeto BeautifulSoup . Este \u00faltimo paso no es estrictamente necesario aunque a veces pueda ayudarnos para que sea m\u00e1s f\u00e1cil entender la estructura de las etiquetas de la p\u00e1gina y el anidado entre ellas. Con la propiedad children de soup podemos seleccionar los elementos del nivel m\u00e1s alto. Estos elementos se devuelven en forma de lista, por lo que necesitaremos la funci\u00f3n list : list ( soup . children ) El resultado del comando de arriba nos indicar\u00e1 que hay dos etiquetas de nivel superior, la etiqueta inicial <!DOCTYPE html> y la etiqueta <html> . Adem\u00e1s aparece un car\u00e1cter de nueva l\u00ednea \\n en la lista tambi\u00e9n. Para saber qu\u00e9 tipo de dato es cada elemento, podemos iterar sobre la lista: [ type ( item ) for item in list ( soup . children )] Veremos de esta forma que que los elementos de la lista son objetos de BeautifulSoup: El primero es un objeto Doctype , que contiene informaci\u00f3n sobre el tipo de documento El segundo es del tipo NavegableString , que indica que se ha encontrado texto el documento HTML. El elemento final es un Tag , que contiene otros tags anidados. El tipo de objeto m\u00e1s importante y con el que lidiaremos m\u00e1s a menudo es el objeto Tag . El objeto Tag nos permite navegar a trav\u00e9s de un documento HTML y extraer otros tags o textos. Aqu\u00ed una lista con los tipos de objetos de BeatifulSoup. Podemos seleccionar ahora el tag html y sus hijos seleccionando el tercer elemnto de la lista: html = list ( soup . children )[ 2 ] Cada elemento devuelto por la porpiedad children es tambi\u00e9n un objeto BeautifulSoup, as\u00ed que podremos seguir invocando el m\u00e9todo children sobre html list ( html . children ) Y podremos seguir iterando sobre los tags anidados hasta aislar el tag p que es el que nos interesa body = list ( html . children )[ 3 ] list ( body . children ) p = list ( body . children )[ 1 ] _ Y una vez aislado, usamos el m\u00e9todo get_text para extraer todo el texto que deseamos: p . get_text () Encontrar todas las instancias de una etiqueta o tag a la vez El proceso que hemos seguido arriba es \u00fatil pero tedioso y poco eficiente. Es por ello, que si quisi\u00e9ramos extraer todas las instancias de un tag dentro de una p\u00e1gina, podemos utilizar el m\u00e9todo find_all : soup = BeautifulSoup ( page . content , 'html.parser' ) soup . find_all ( 'p' ) Este m\u00e9todo devuelve una lista, as\u00ed que tendremos que iterar sobre ella o usar \u00edndices para extraer el texto: soup . find_all ( 'p' )[ 0 ] . get_text () Para encontrar la primera instancia que aparece en la p\u00e1gina de un determinado tag, usaremos el m\u00e9todo find , que devuelve un \u00fanico objeto BeautifulSoup: soup . find ( 'p' ) Buscando etiquetas usando \"class\" y \"id\" Estos dos elementos, introducidos con anteriorirdad, se usan en CSS para determinar a qu\u00e9 elementos HTML se est\u00e1n aplicando ciertos estilos. Pero cuando estamos haciendo scraping tambi\u00e9n podemos usarlos para escpeificar los elementos que queremos scrapear . Para ilustrar esta secci\u00f3n, vamos a trabajar con la siguiente p\u00e1gina: < html > < head > < title > A simple example page </ title > </ head > < body > < div > < p class = \"inner-text first-item\" id = \"first\" > First paragraph. </ p > < p class = \"inner-text\" > Second paragraph. </ p > </ div > < p class = \"outer-text first-item\" id = \"second\" > < b > First outer paragraph. </ b > </ p > < p class = \"outer-text\" > < b > Second outer paragraph. </ b > </ p > </ body > </ html > Que podemos encontrar aqu\u00ed . Seguimos el mismo modus operandi, descargamos la p\u00e1gina y creamos un objeto BeautifulSoup: page = requests . get ( \"https://dataquestio.github.io/web-scraping-pages/ids_and_classes.html\" ) soup = BeautifulSoup ( page . content , 'html.parser' ) soup Ahora, para encontrar todos los elementos con el tag p con un class igual a outer-text : soup . find_all ( 'p' , class_ = 'outer-text' ) O simplemente cualquier tag con ese class : soup . find_all ( class_ = \"outer-text\" ) O buscar tambi\u00e9n por id : soup . find_all ( id = \"first\" ) Usando selectores CSS Tambi\u00e9n podemos buscar elementos usando los selectores CSS . Mediante estos selectores el lenguaje CSS permite a los desarrolladores especificar las etiquetas HTML a las que aplicar estilos. Algunos ejemplos: p a : encuentra todos los tags a dentro de un tag p body p a : encuentra todos los tags a dentro de un tag p dentro de un tag body html body : encuentra todos los tags body dentro deun tag html p.outer-text : encuentra todos los tags p con la class outer-text p#first : encuentra todos los tags p con un id first body p.outer-text : encuentra todos los tags p con la class outer-text dentro de un tag body BeautifulSoup soporta la b\u00fasqueda en una p\u00e1gina usando selectores CSS usando el m\u00e9todo select . Podemos usar estos selectores para encontrar todos los tags p de nuestra p\u00e1gina que est\u00e9 dentro de un div tal que as\u00ed: soup . select ( \"div p\" ) Note El m\u00e9todo select de arriba devuelve una lista de objetos BeautifulSoup, igual que find y find_all Ejemplo pr\u00e1ctico: Scraping de datos meteorol\u00f3gicos Para este ejemplo se utilizar\u00e1 la p\u00e1gina de informaci\u00f3n del tiempo de San Francisco Como vemos en la imagen, la p\u00e1gina contiene informaci\u00f3n ampliada de la previsi\u00f3n meteorol\u00f3gica para la semana que viene, incluyendo cosas como la temperatura o una breve descripci\u00f3n de las condiciones. Explorando la estructura de la p\u00e1gina con las herramientas de desarrollador Para acceder a las herramientas de desarrollador de nuestro navegador podemos apretar simplemente F12 o podemos encontrarlas en Herramientas > Herramientas del navegador > Herramientas para desarrolladores web (en Firefox, en otros navegadores ser\u00e1 similar). Si os coloc\u00e1is sobre la pesta\u00f1a Inspector , se os mostrar\u00e1n todas las etiquetas/tags de la p\u00e1gina y podr\u00e9is navegar por ellas: Si hacemos click derecho en la p\u00e1gina, cerca de donde pone Extended forecast y le decimos Inspeccinoar , se nos abrir\u00e1 el tag donde est\u00e1n contenidos esos elementos: En la pesta\u00f1a de Elements tambi\u00e9n podemos ir navegando por los distintos elementos para encontrar el que contiene todo el texto que corresponde con la informaci\u00f3n del tiempo ampliada (extended forecasts). En este caso, como v\u00e9is en la imagen de arriba, se trata de un div con el id seven-day-forecast . Si trasteamos un poco en la consola, podremos explorar el diva y descubiremos que cada elemento del tiempo (Tonight, Thursday, Thursday night...) est\u00e1 contenido en un div con la class tombstone-container . \u00a1Empecemos con el scraping! Ya tenemos todo lo que ncesitamos para descargarnos la p\u00e1gina y empezar a parsear como si no hubiera un ma\u00f1ana. Lo que haremos, ser\u00e1: Descargar la p\u00e1gina web que contiene la previsi\u00f3n del tiempo Crear una clase BeautifulSoup para parsear la p\u00e1gina Encontrar el div con id seven-day-forecast y asignarlo a la variable seven_day Dentro de seven_day deberemos encontrar cada elemento indiivdual de la previsi\u00f3n del tiempo Extraer e imprimir el primero de estos elementos Esto, traducido a c\u00f3digo Python, ser\u00eda: pagina = requests . get ( \"https://forecast.weather.gov/MapClick.php?lat=37.7772&lon=-122.4168\" ) soup = BeautifulSoup ( pagina . content , 'html.parser' ) seven_day = soup . find ( id = \"seven-day-forecast\" ) elementos_clima = seven_day . find_all ( class_ = \"tombstone-container\" ) tonight = elementos_clima [ 0 ] print ( tonight . prettify ()) Extraer informaci\u00f3n concreta de la p\u00e1gina Vemos que dentro del elemento tonight est\u00e1 toda la informaci\u00f3n que deseamos. Hay cuatro piezas de informaci\u00f3n que podemos extraer: El nombre del elemento, en este caso Tonight La descripci\u00f3n de las condiciones, almacenadas en la propiedad title de img Una breve descripci\u00f3n de las condiciones, en este caso Mostly Clear La m\u00ednima de temperatura, en este caso 58\u00baF Para extraer pues la informaci\u00f3n m\u00e1s relevante, siguiendo con el ejemplo anterior, podemos hacer: periodo = tonight . find ( class_ = \"period-name\" ) . get_text () desc_corta = tonight . find ( class_ = \"short-desc\" ) . get_text () temp = tonight . find ( class_ = \"temp\" ) . get_text () print ( periodo ) print ( desc_corta ) print ( temp ) Ahora, podemos extraer el atributo title de la etiqueta img . Para hacer esto, trataremos al objeto BeautifulSoup como un diccionario y le pasaremos el atributo que queremos como una clave: img = tonight . find ( \"img\" ) desc = img [ 'title' ] print ( desc ) Extraer toda la informaci\u00f3n de la p\u00e1gina Ahora que ya sabemos como extraer piezas de informaci\u00f3n de forma individual, podemos combinar nuestros vastos conocimientos junto con los selectores CSS y las list comprehensions para extraerlo todo a la vez. Los pasos a seguir para el ejemplo que nos ocupa, son: Seleccionar todos los elementos con la class period-name dentro de un elemento con la class tombstone-container que tengamos en la variable seven_day Usar una list comprehension para invocar al m\u00e9todo get_text en cada objeto BeautifulSoup. tags_periodo = seven_day . select ( \".tombstone-container .period-name\" ) periodos = [ pt . get_text () for pt in tags_periodo ] periodos A partir de aqu\u00ed ya podr\u00edamos tratar la informaci\u00f3n extra\u00edda con bibliotecas como Pandas , convirti\u00e9ndola en diccionarios y tablas. Sin embargo, a nosotros por lo general s\u00f3lo nos interesar\u00e1 identificar y manipular campos de formularios con el fin de explotar diferentes fallos como puedan ser SQLi, enumeraci\u00f3n de usuarios o fuerza bruta entre otros. Referencias Web Scraping with Python Using Beautiful Soup","title":"BeautifulSoup"},{"location":"beauty/#beautiful-soup","text":"","title":"Beautiful Soup"},{"location":"beauty/#web-scraping","text":"Internet es una fuente de datos absolutamente masiva, datos a los que podemos acceder mediante el web scraping y Python. De hecho, el web scraping es a menudo la \u00fanica forma de acceder a los datos. Hay mucha informaci\u00f3n ah\u00ed fuera que no est\u00e1 disponible mediante c\u00f3modas exportaciones CSV o APIs f\u00e1ciles de conectar. Adem\u00e1s, los propios sitios web son a menudo valiosas fuentes de datos. Pensemos, por ejemplo, en el tipo de an\u00e1lisis que se podr\u00eda hacer si pudieramos descargar todos los mensajes de un foro web. Para acceder a este tipo de conjuntos de datos en la p\u00e1gina, tendremos que utilizar el web scraping.","title":"Web scraping"},{"location":"beauty/#fundamentos-del-web-scraping","text":"Algunos sitios web ofrecen conjuntos de datos que se pueden descargar en formato CSV, o que son accesibles a trav\u00e9s de una interfaz de programaci\u00f3n de aplicaciones (API) . Pero muchos sitios web con datos \u00fatiles no ofrecen este tipo de opciones. Veamos, por ejemplo, el caso del sitio web del Servicio Meteorol\u00f3gico Nacional de EEUU. Contiene previsiones meteorol\u00f3gicas actualizadas para todos los lugares de Estados Unidos, pero esos datos meteorol\u00f3gicos no son accesibles en formato CSV ni a trav\u00e9s de la API. Hay que verlos en el propio sitio del NWS: Si quisi\u00e9ramos analizar estos datos, o descargarlos para utilizarlos en alguna otra aplicaci\u00f3n, no querr\u00edamos copiar y pegar todo a mano. El \"web scraping\" es una t\u00e9cnica que nos permite utilizar la programaci\u00f3n para hacer el trabajo pesado. Vamos a escribir un c\u00f3digo que busque en el sitio del NWS, coja s\u00f3lo los datos con los que queremos trabajar y los proporcione en el formato que necesitamos. Cuando hacemos scraping de la web, escribimos un c\u00f3digo que env\u00eda una petici\u00f3n al servidor que aloja la p\u00e1gina que hemos especificado. El servidor devolver\u00e1 el c\u00f3digo fuente - HTML, principalmente - de la p\u00e1gina (o p\u00e1ginas) que hemos solicitado. Hasta aqu\u00ed, estamos haciendo esencialmente lo mismo que hace un navegador web: enviar una petici\u00f3n al servidor con una URL espec\u00edfica y pedirle que nos devuelva el c\u00f3digo de esa p\u00e1gina. Pero a diferencia de un navegador web, nuestro c\u00f3digo de web scraping no interpretar\u00e1 el c\u00f3digo fuente de la p\u00e1gina y la mostrar\u00e1 visualmente. En su lugar, escribiremos un c\u00f3digo personalizado que filtrar\u00e1 dicho c\u00f3digo fuente en busca de los elementos concretos que hayamos especificado y extraer\u00e1 el contenido que le hayamos indicado. Por ejemplo, si quisi\u00e9ramos obtener todos los datos del interior de una tabla que se muestra en una p\u00e1gina web, nuestro c\u00f3digo se escribir\u00eda para seguir estos pasos en secuencia: Solicitar al servidor el contenido (c\u00f3digo fuente) de una URL espec\u00edfica Descargar el contenido devuelto Identificar los elementos de la p\u00e1gina que forman parte de la tabla que queremos Extraer y (si es necesario) reformatear esos elementos en un conjunto de datos que podamos analizar o utilizar de la forma que queramos. Si todo esto suena muy complicado, no hay de qu\u00e9 preocuparse, Python y Beautiful Soup tienen funciones integradas dise\u00f1adas para que esto sea relativamente sencillo. Una cosa que es importante tener en cuenta: desde la perspectiva de un servidor, solicitar una p\u00e1gina a trav\u00e9s de web scraping es lo mismo que cargarla en un navegador web. Cuando usamos c\u00f3digo para enviar estas peticiones, podemos estar \"cargando\" p\u00e1ginas mucho m\u00e1s r\u00e1pido que un usuario normal, y por tanto consumiendo r\u00e1pidamente los recursos del servidor del propietario del sitio web.","title":"Fundamentos del web scraping"},{"location":"beauty/#es-legal-el-web-scraping","text":"Desafortunadamente, no hay una respuesta clara en este aspecto. Algunos sitios web permiten expl\u00edcitamente el web scraping mientras que otros lo proh\u00edben expl\u00edcitamente. Muchos sitios web no ofrecen ninguna orientaci\u00f3n clara en un sentido u otro. Antes de hacer scraping de cualquier sitio web, debemos buscar una p\u00e1gina de t\u00e9rminos y condiciones para ver si hay normas expl\u00edcitas sobre el scraping. Si las hay, debemos cumplirlas. Si no las hay, se trata m\u00e1s bien de una cuesti\u00f3n de criterio. Sin embargo, hay que recordar que el scraping consume recursos del servidor del sitio web anfitri\u00f3n. Si s\u00f3lo hacemos scraping de una p\u00e1gina una vez, eso no va a causar un problema. Pero si nuestro c\u00f3digo est\u00e1 haciendo scraping de 1.000 p\u00e1ginas una vez cada diez minutos, eso r\u00e1pidamente podr\u00eda convertirse en un problema de costes para el propietario del sitio web. Por lo tanto, adem\u00e1s de seguir todas y cada una de las reglas expl\u00edcitas sobre el web scraping publicadas en el sitio, tambi\u00e9n es una buena idea seguir una serie de buenas pr\u00e1cticas recomendadas: Nunca hacer scraping con m\u00e1s frecuencia de la necesaria. Considerar la posibilidad de almacenar en cach\u00e9 el contenido que se obtenga procedente el scraping para que s\u00f3lo se descargue una vez. Incorpora pausas en tu c\u00f3digo utilizando funciones como time.sleep() para no abrumar a los servidores con demasiadas peticiones demasiado r\u00e1pido. En el ejemplo que nos ocupa, los datos del NWS son de dominio p\u00fablico y sus condiciones no proh\u00edben el scraping de la web, por lo que estamos en condiciones de proceder.","title":"\u00bfEs legal el Web Scraping?"},{"location":"beauty/#componentes-de-una-pagina-web","text":"Antes de empezar a escribir c\u00f3digo, necesitamos entender un poco acerca de la estructura de una p\u00e1gina web ya que es lo que utilizaremos los datos deseados cuando hagamos scraping. Cuando visitamos un sitio web, nuesro navegador hace una petici\u00f3n a un servidor web. Esta petici\u00f3n ser\u00e1 de tipo GET puesto que estamos obteniendo ficheros del servidor. El servidor env\u00eda de vuelta al navegador los ficheros que le indican c\u00f3mo tiene que renderizar la p\u00e1gina para el usuario. Estos archivos t\u00edpicamente incluir\u00e1n: HTML: el contenido principal de la p\u00e1gina CSS: usado para a\u00f1adir estilos a las p\u00e1ginas y mejorar su aspecto JS: Javascript a\u00f1ade interactividad a la p\u00e1gina web. Im\u00e1genes: Para ser mostradas en el sitio Como hemos dicho ya, tras recibir los archivos, el navegador renderiza la p\u00e1gina y la muestra. A la hora de llevar a cabo el scrapig, estamos interesados en el contenido principal de la web as\u00ed que miraremos principalmente el c\u00f3digo HTML.","title":"Componentes de una p\u00e1gina web"},{"location":"beauty/#html","text":"HTML es el lenguaje en el que est\u00e1n creados los sitios web. No se tata de un lenguaje de programaci\u00f3n como pueda serlo Python. Es un lenguaje de marcado que le dice al navegador como mostrar contenido. HTML tiene varias que son similiares a lo que se pudiera hacer con un procesador de textos (negrita, p\u00e1rrafos...). Hagamos un rapid\u00edsimo repaso de HTML. HTML est\u00e1 formado por elementos llamados tags o etiquetas . El m\u00e1s b\u00e1sico es <html> y es el que le indica al navegador que todo lo que vaya dentro de \u00e9l es HTML. As\u00ed pues, el documento HTML m\u00e1s simple ser\u00eda: < html > </ html > No hemos a\u00f1adido contenido a nuestra p\u00e1gina todav\u00eda as\u00ed que este documento HTML no mostrar\u00eda nada en un navegador. Podemos poner m\u00e1s etiquetas dentro de las etiquetas html : < html > < head > </ head > < body > </ body > </ html > El contenido principal del sitio web lo podremos encontrar dnetro de las etiquetas body . La etiqueta head contiene informaci\u00f3n acerca dle t\u00edtulo de la p\u00e1gina as\u00ed como otro tipo de informaci\u00f3n no \u00fatil para el web scraping. A\u00f1adamos ahora un p\u00e1rrafo dentro del body con su correspondiente etiqueta p : < html > < head > </ head > < body > < p > Primer p\u00e1rrafo </ p > < p > Segundo p\u00e1rrafo </ p > </ body > </ html > Podemos adem\u00e1s a\u00f1adir propiedades a las etiquetas HML que cambien su comportamiento. A\u00f1adamos ahora hiperenlaces con la etiqueta a : < html > < head > </ head > < body > < p > Primer p\u00e1rrafo < a href = \"https://www.dataquest.io\" > Learn Data Science Online </ a > </ p > < p > Segundo p\u00e1rrafo < a href = \"https://www.python.org\" > Python </ a > </ p > </ body > </ html > Que se ver\u00e1 as\u00ed: En el ejemplo anterio la etiqueta a indica que se trata de un link y la propiedad href determina a donde apunta ese link. Otras etiquetas comunes son: div: indica una divisi\u00f3n o \u00e1rea de la p\u00e1gina b: texto en negrita i: texto en cursiva table: crea una tabla form: crea un formulario Aqu\u00ed pod\u00e9is encontrar la lista completa de tags o etiquetas. Para acabar con el apartado dedicado a HTML, debemos hablar de las propiedades class y id . Estas propiedade especiales proporciona nombres a los elementos HTML, haciendo as\u00ed m\u00e1s f\u00e1cil interactuar con ellos a la hora de hacer scraping. Un elemento puede tener multiples clases y una clase puede ser compartida entre elementos. Cada elemento s\u00f3lo puede tener un \u00fanico id y un id s\u00f3lo puede usarse una vez por p\u00e1gina. Estos class y id son opcinoales y no todos los elementos los tendr\u00e1n. Sobre el ejemplo anterior: < html > < head > </ head > < body > < p class = \"bold-paragraph\" > Primer p\u00e1rrafo < a href = \"https://www.dataquest.io\" id = \"learn-link\" > Learn Data Science Online </ a > </ p > < p class = \"bold-paragraph extra-large\" > Segundo p\u00e1rrafo < a href = \"https://www.python.org\" class = \"extra-large\" > Python </ a > </ p > </ body > </ html > Estas propiedades no modifican la forma en que se ve la p\u00e1gina en el navegador.","title":"HTML"},{"location":"beauty/#parseando-paginas-con-beatifulsoup","text":"El parsing no es m\u00e1s que un an\u00e1lisis sint\u00e1ctico, como pod\u00e9is leer aqu\u00ed Supongamos que descargamos la siguiente p\u00e1gina usando la biblioteca Requests que ya hemos visto: import requests page = requests . get ( \"https://dataquestio.github.io/web-scraping-pages/simple.html\" ) page Podemos utilizar la biblioteca BeautifulSoup para parsear este documento y extraer el texto de la etiqueta p . Lo primero que deberemos hacer, como siempre, es instalar BeautifulSoup. Podemos hacerlo en nuestro entorno virtual: O de forma general en nuestra m\u00e1quina: pipenv shell pipenv install beautifulsoup4 Ahora, en el entorno interactivo de python, podemos proceder: Lo que hemos hecho ha sido importar la biblioteca y crear una instancia de la clase BeautifulSoup para parsear nuestro documento. Tras ello, hemos mostrado por pantall el contenido de la p\u00e1gina de una forma un poco m\u00e1s bonita utilizando el m\u00e9todo prettify del objeto BeautifulSoup . Este \u00faltimo paso no es estrictamente necesario aunque a veces pueda ayudarnos para que sea m\u00e1s f\u00e1cil entender la estructura de las etiquetas de la p\u00e1gina y el anidado entre ellas. Con la propiedad children de soup podemos seleccionar los elementos del nivel m\u00e1s alto. Estos elementos se devuelven en forma de lista, por lo que necesitaremos la funci\u00f3n list : list ( soup . children ) El resultado del comando de arriba nos indicar\u00e1 que hay dos etiquetas de nivel superior, la etiqueta inicial <!DOCTYPE html> y la etiqueta <html> . Adem\u00e1s aparece un car\u00e1cter de nueva l\u00ednea \\n en la lista tambi\u00e9n. Para saber qu\u00e9 tipo de dato es cada elemento, podemos iterar sobre la lista: [ type ( item ) for item in list ( soup . children )] Veremos de esta forma que que los elementos de la lista son objetos de BeautifulSoup: El primero es un objeto Doctype , que contiene informaci\u00f3n sobre el tipo de documento El segundo es del tipo NavegableString , que indica que se ha encontrado texto el documento HTML. El elemento final es un Tag , que contiene otros tags anidados. El tipo de objeto m\u00e1s importante y con el que lidiaremos m\u00e1s a menudo es el objeto Tag . El objeto Tag nos permite navegar a trav\u00e9s de un documento HTML y extraer otros tags o textos. Aqu\u00ed una lista con los tipos de objetos de BeatifulSoup. Podemos seleccionar ahora el tag html y sus hijos seleccionando el tercer elemnto de la lista: html = list ( soup . children )[ 2 ] Cada elemento devuelto por la porpiedad children es tambi\u00e9n un objeto BeautifulSoup, as\u00ed que podremos seguir invocando el m\u00e9todo children sobre html list ( html . children ) Y podremos seguir iterando sobre los tags anidados hasta aislar el tag p que es el que nos interesa body = list ( html . children )[ 3 ] list ( body . children ) p = list ( body . children )[ 1 ] _ Y una vez aislado, usamos el m\u00e9todo get_text para extraer todo el texto que deseamos: p . get_text ()","title":"Parseando p\u00e1ginas con BeatifulSoup"},{"location":"beauty/#encontrar-todas-las-instancias-de-una-etiqueta-o-tag-a-la-vez","text":"El proceso que hemos seguido arriba es \u00fatil pero tedioso y poco eficiente. Es por ello, que si quisi\u00e9ramos extraer todas las instancias de un tag dentro de una p\u00e1gina, podemos utilizar el m\u00e9todo find_all : soup = BeautifulSoup ( page . content , 'html.parser' ) soup . find_all ( 'p' ) Este m\u00e9todo devuelve una lista, as\u00ed que tendremos que iterar sobre ella o usar \u00edndices para extraer el texto: soup . find_all ( 'p' )[ 0 ] . get_text () Para encontrar la primera instancia que aparece en la p\u00e1gina de un determinado tag, usaremos el m\u00e9todo find , que devuelve un \u00fanico objeto BeautifulSoup: soup . find ( 'p' )","title":"Encontrar todas las instancias de una etiqueta o tag a la vez"},{"location":"beauty/#buscando-etiquetas-usando-class-y-id","text":"Estos dos elementos, introducidos con anteriorirdad, se usan en CSS para determinar a qu\u00e9 elementos HTML se est\u00e1n aplicando ciertos estilos. Pero cuando estamos haciendo scraping tambi\u00e9n podemos usarlos para escpeificar los elementos que queremos scrapear . Para ilustrar esta secci\u00f3n, vamos a trabajar con la siguiente p\u00e1gina: < html > < head > < title > A simple example page </ title > </ head > < body > < div > < p class = \"inner-text first-item\" id = \"first\" > First paragraph. </ p > < p class = \"inner-text\" > Second paragraph. </ p > </ div > < p class = \"outer-text first-item\" id = \"second\" > < b > First outer paragraph. </ b > </ p > < p class = \"outer-text\" > < b > Second outer paragraph. </ b > </ p > </ body > </ html > Que podemos encontrar aqu\u00ed . Seguimos el mismo modus operandi, descargamos la p\u00e1gina y creamos un objeto BeautifulSoup: page = requests . get ( \"https://dataquestio.github.io/web-scraping-pages/ids_and_classes.html\" ) soup = BeautifulSoup ( page . content , 'html.parser' ) soup Ahora, para encontrar todos los elementos con el tag p con un class igual a outer-text : soup . find_all ( 'p' , class_ = 'outer-text' ) O simplemente cualquier tag con ese class : soup . find_all ( class_ = \"outer-text\" ) O buscar tambi\u00e9n por id : soup . find_all ( id = \"first\" )","title":"Buscando etiquetas usando \"class\" y \"id\""},{"location":"beauty/#usando-selectores-css","text":"Tambi\u00e9n podemos buscar elementos usando los selectores CSS . Mediante estos selectores el lenguaje CSS permite a los desarrolladores especificar las etiquetas HTML a las que aplicar estilos. Algunos ejemplos: p a : encuentra todos los tags a dentro de un tag p body p a : encuentra todos los tags a dentro de un tag p dentro de un tag body html body : encuentra todos los tags body dentro deun tag html p.outer-text : encuentra todos los tags p con la class outer-text p#first : encuentra todos los tags p con un id first body p.outer-text : encuentra todos los tags p con la class outer-text dentro de un tag body BeautifulSoup soporta la b\u00fasqueda en una p\u00e1gina usando selectores CSS usando el m\u00e9todo select . Podemos usar estos selectores para encontrar todos los tags p de nuestra p\u00e1gina que est\u00e9 dentro de un div tal que as\u00ed: soup . select ( \"div p\" ) Note El m\u00e9todo select de arriba devuelve una lista de objetos BeautifulSoup, igual que find y find_all","title":"Usando selectores CSS"},{"location":"beauty/#ejemplo-practico-scraping-de-datos-meteorologicos","text":"Para este ejemplo se utilizar\u00e1 la p\u00e1gina de informaci\u00f3n del tiempo de San Francisco Como vemos en la imagen, la p\u00e1gina contiene informaci\u00f3n ampliada de la previsi\u00f3n meteorol\u00f3gica para la semana que viene, incluyendo cosas como la temperatura o una breve descripci\u00f3n de las condiciones.","title":"Ejemplo pr\u00e1ctico: Scraping de datos meteorol\u00f3gicos"},{"location":"beauty/#explorando-la-estructura-de-la-pagina-con-las-herramientas-de-desarrollador","text":"Para acceder a las herramientas de desarrollador de nuestro navegador podemos apretar simplemente F12 o podemos encontrarlas en Herramientas > Herramientas del navegador > Herramientas para desarrolladores web (en Firefox, en otros navegadores ser\u00e1 similar). Si os coloc\u00e1is sobre la pesta\u00f1a Inspector , se os mostrar\u00e1n todas las etiquetas/tags de la p\u00e1gina y podr\u00e9is navegar por ellas: Si hacemos click derecho en la p\u00e1gina, cerca de donde pone Extended forecast y le decimos Inspeccinoar , se nos abrir\u00e1 el tag donde est\u00e1n contenidos esos elementos: En la pesta\u00f1a de Elements tambi\u00e9n podemos ir navegando por los distintos elementos para encontrar el que contiene todo el texto que corresponde con la informaci\u00f3n del tiempo ampliada (extended forecasts). En este caso, como v\u00e9is en la imagen de arriba, se trata de un div con el id seven-day-forecast . Si trasteamos un poco en la consola, podremos explorar el diva y descubiremos que cada elemento del tiempo (Tonight, Thursday, Thursday night...) est\u00e1 contenido en un div con la class tombstone-container .","title":"Explorando la estructura de la p\u00e1gina con las herramientas de desarrollador"},{"location":"beauty/#empecemos-con-el-scraping","text":"Ya tenemos todo lo que ncesitamos para descargarnos la p\u00e1gina y empezar a parsear como si no hubiera un ma\u00f1ana. Lo que haremos, ser\u00e1: Descargar la p\u00e1gina web que contiene la previsi\u00f3n del tiempo Crear una clase BeautifulSoup para parsear la p\u00e1gina Encontrar el div con id seven-day-forecast y asignarlo a la variable seven_day Dentro de seven_day deberemos encontrar cada elemento indiivdual de la previsi\u00f3n del tiempo Extraer e imprimir el primero de estos elementos Esto, traducido a c\u00f3digo Python, ser\u00eda: pagina = requests . get ( \"https://forecast.weather.gov/MapClick.php?lat=37.7772&lon=-122.4168\" ) soup = BeautifulSoup ( pagina . content , 'html.parser' ) seven_day = soup . find ( id = \"seven-day-forecast\" ) elementos_clima = seven_day . find_all ( class_ = \"tombstone-container\" ) tonight = elementos_clima [ 0 ] print ( tonight . prettify ())","title":"\u00a1Empecemos con el scraping!"},{"location":"beauty/#extraer-informacion-concreta-de-la-pagina","text":"Vemos que dentro del elemento tonight est\u00e1 toda la informaci\u00f3n que deseamos. Hay cuatro piezas de informaci\u00f3n que podemos extraer: El nombre del elemento, en este caso Tonight La descripci\u00f3n de las condiciones, almacenadas en la propiedad title de img Una breve descripci\u00f3n de las condiciones, en este caso Mostly Clear La m\u00ednima de temperatura, en este caso 58\u00baF Para extraer pues la informaci\u00f3n m\u00e1s relevante, siguiendo con el ejemplo anterior, podemos hacer: periodo = tonight . find ( class_ = \"period-name\" ) . get_text () desc_corta = tonight . find ( class_ = \"short-desc\" ) . get_text () temp = tonight . find ( class_ = \"temp\" ) . get_text () print ( periodo ) print ( desc_corta ) print ( temp ) Ahora, podemos extraer el atributo title de la etiqueta img . Para hacer esto, trataremos al objeto BeautifulSoup como un diccionario y le pasaremos el atributo que queremos como una clave: img = tonight . find ( \"img\" ) desc = img [ 'title' ] print ( desc )","title":"Extraer informaci\u00f3n concreta de la p\u00e1gina"},{"location":"beauty/#extraer-toda-la-informacion-de-la-pagina","text":"Ahora que ya sabemos como extraer piezas de informaci\u00f3n de forma individual, podemos combinar nuestros vastos conocimientos junto con los selectores CSS y las list comprehensions para extraerlo todo a la vez. Los pasos a seguir para el ejemplo que nos ocupa, son: Seleccionar todos los elementos con la class period-name dentro de un elemento con la class tombstone-container que tengamos en la variable seven_day Usar una list comprehension para invocar al m\u00e9todo get_text en cada objeto BeautifulSoup. tags_periodo = seven_day . select ( \".tombstone-container .period-name\" ) periodos = [ pt . get_text () for pt in tags_periodo ] periodos A partir de aqu\u00ed ya podr\u00edamos tratar la informaci\u00f3n extra\u00edda con bibliotecas como Pandas , convirti\u00e9ndola en diccionarios y tablas. Sin embargo, a nosotros por lo general s\u00f3lo nos interesar\u00e1 identificar y manipular campos de formularios con el fin de explotar diferentes fallos como puedan ser SQLi, enumeraci\u00f3n de usuarios o fuerza bruta entre otros.","title":"Extraer toda la informaci\u00f3n de la p\u00e1gina"},{"location":"beauty/#referencias","text":"Web Scraping with Python Using Beautiful Soup","title":"Referencias"},{"location":"bibliografia/","text":"Python para todos C\u00f3mo pensar como un inform\u00e1tico Python crash course Curso Python de la NSA Inmersi\u00f3n en Python3 Aprende Python de cero a experto Learning Python","title":"Bibliograf\u00eda"},{"location":"condicionales/","text":"Estructuras de control Condicionales Las estructuras de control se utilizan para ejecutar bloques de c\u00f3digo en funci\u00f3n de condiciones . Sentencia IF - ELSE Se eval\u00faa la condici\u00f3n especificada en la sentencia if y en caso de cumplirse se ejecutar\u00e1 el bloque de c\u00f3digo indentado (tabulado). En caso de que el resultado de la condici\u00f3n sea False , el bloque especificado no se ejecutar\u00e1: numero = 5 if numero > 1 : # Se ejecutar\u00e1 cuando la condici\u00f3n sea True print ( \"Es mayor que uno\" ) Las condiciones pueden tener mayor complejidad: edad = 16 altura = 175 if ( edad > 14 and altura > 160 ): print ( \"Puede montarse en la monta\u00f1a rusa\" ) Mediante la palabra reservada else es posible especificar un bloque de c\u00f3digo que se ejecute en caso de que la condici\u00f3n no se cumpla: numero = 2 if numero > 10 : # Se ejecutar\u00e1 cuando la condici\u00f3n sea True print ( \"Es mayor que diez\" ) else : # Se ejecutar\u00e1 cuando la condici\u00f3n sera False print ( \"Es menor o igual que diez\" ) Tambi\u00e9n podemos comprobar m\u00e1s condiciones mediante la expresi\u00f3n elif . En este caso, se seguir\u00e1n comprobando todas las condiciones elif hasta que una de ellas se cumpla. En caso contrario, se ejecutar\u00e1 el bloque de c\u00f3digo dentro de else (si lo hubiera). numero = 5 if numero < 3 : print ( \"Es menor que 3\" ) elif numero < 6 : print ( \"El n\u00famero est\u00e1 entre el 3 y el 5\" ) else : print ( \"Es mayor o igual a 6\" ) Tal y como muestra el siguiente c\u00f3digo de ejemplo, Python no tiene limitaciones para anidar distintos bloques de IF s. numero = 2 if numero >= 0 : if numero == 0 : print ( \"El valor es 0\" ) else : print ( \"Es un n\u00famero positivo\" ) else : print ( \"Es un n\u00famero negativo\" ) Bucles Los bucles permiten ejecutar un bloque de c\u00f3digo tantas veces como queramos. Sentencia WHILE La sentencia while permite ejecutar un bloque de c\u00f3digo mientras la expresi\u00f3n que definamos se cumpla (es decir, devuelva True ). Python interpretar\u00e1 como True cualquier valor distinto a 0 o None . contador = 0 while ( contador < 5 ): # Se ejecutar\u00e1 mientras la variable contador sea menor a 5. contador = contador + 1 print ( \"Iteraci\u00f3n n\u00famero\" , contador ) print ( \"\u00a1Fin!\" ) Para detener una ejecuci\u00f3n de forma voluntaria se utiliza la sentencia break : contador = 0 while ( contador < 5 ): contador = contador + 1 print ( \"Iteraci\u00f3n n\u00famero\" , contador ) if contador == 3 : break print ( \"\u00a1Fin!\" ) Tambi\u00e9n es posible saltar \u00fanicamente la iteraci\u00f3n actual mediante la sentencia continue : contador = 0 while ( contador < 5 ): contador = contador + 1 if contador == 3 : continue print ( \"Iteraci\u00f3n n\u00famero {} \" . format ( contador )) print ( \"\u00a1Fin!\" ) La salida del programa anterior ser\u00e1 la siguiente: Iteraci\u00f3n n\u00famero 1 Iteraci\u00f3n n\u00famero 2 Iteraci\u00f3n n\u00famero 4 Iteraci\u00f3n n\u00famero 5 Bucle while finalizado Otros lenguajes de programaci\u00f3n ofrecen otra estructura similar conocida como DO - WHILE . No es el caso de Python, por lo que habr\u00eda que emular dicho comportamiento mediante nuestro c\u00f3digo. Bucle WHILE con ELSE La expresi\u00f3n else puede utilizarse tambi\u00e9n tras un bloque while . De este forma podemos definir un bloque de c\u00f3digo que se ejecutar\u00e1 una vez finalizado el bloque while (es decir, cuando la condici\u00f3n se eval\u00fae False y no se haya finalizado mediante un break ): count = 0 while ( count < 5 ): count = count + 1 print ( \"Iteraci\u00f3n n\u00famero {} \" . format ( count )) else : print ( \"Bucle while finalizado\" ) Sentencia FOR A diferencia de otros lenguajes de programaci\u00f3n, en Python la sentencia FOR itera \u00fanicamente por secuencias (listas, tuplas, cadenas de caracteres,...). alumnos = [ \"Ane\" , \"Mikel\" , \"Unai\" , \"Lorea\" ] for alumno in alumnos : print ( alumno ) Tambi\u00e9n es posible utilizarlo para recorrer un string: frase = \"Aprendiendo Python\" for c in frase : print ( c ) Para detener una ejecuci\u00f3n se utiliza la sentencia break : numeros = [ 4 , 8 , 2 , 7 , 1 , 9 , 3 , 5 ] total = 0 for n in numeros : total += n if total > 10 : break Al igual que en otras estructuras de repetici\u00f3n, tambi\u00e9n es posible saltar \u00fanicamente la iteraci\u00f3n actual mediante la sentencia continue : numeros = [ 4 , 8 , 2 , 7 , 1 , 9 , 3 , 5 ] total = 0 # solo sumar los n\u00fameros impares for num in numeros : if num % 2 == 0 : print ( \"Numero par, no lo sumamos\" ) continue total += n Bucle FOR con ELSE Python permite definir un bloque de c\u00f3digo que se ejecutar\u00e1 una vez finalice la iteraci\u00f3n por todos los elementos de una lista. Es importante mencionar que no se ejecutar\u00e1 si se ha finalizado mediante break . alumnos = [ \"Ane\" , \"Mikel\" , \"Unai\" , \"Lorea\" ] for alumno in alumnos : print ( alumno ) else : print ( \"No quedan m\u00e1s alumnos.\" ) La funci\u00f3n range() La funci\u00f3n range([start,] stop [, step]) devuelve una secuencia de n\u00fameros. Es por ello que se utiliza de forma frecuente para iterar: for i in range ( 3 ): print ( i ) # 0 # 1 # 2 Tambi\u00e9n podemos indicar el inicio, fin y step: print ( \"N\u00fameros del 5 al 10\" ) for i in range ( 5 , 10 ): print ( i , end = ', ' ) # 5, 6, 7, 8, 9, print ( \"N\u00fameros impares del 1 al 10\" ) for i in range ( 1 , 10 , 2 ): print ( i , end = ', ' ) # 1, 3, 5, 7, 9, Para iterar por una lista utilizando el \u00edndice, basta con combinarlo con la funci\u00f3n len() : alumnos = [ \"Ane\" , \"Mikel\" , \"Unai\" , \"Lorea\" ] for i in range ( len ( alumnos )): print ( alumnos [ i ]) Captura de excepciones usando try y except Imaginemos un script donde utilicemos las funciones input e int para leer y analizar un n\u00famero entero introducido por el usuario. Resulta poco seguro realizar esta acci\u00f3n de esta forma: >>> velocidad = input ( prompt ) \u00bf Cual .... es la velocidad de vuelo de una golondrina sin carga ? \u00bf Te refieres a una golondrina africana o a una europea ? >>> int ( velocidad ) ValueError : invalid literal for int () with base 10 : >>> Cuando estamos trabajando con el int\u00e9rprete de Python, tras el error simplemente nos aparece de nuevo el prompt, as\u00ed que pensamos \u201c\u00a1epa, me he equivocado!\u201d, y continuamos con la siguiente sentencia. Sin embargo, si se escribe ese c\u00f3digo en un script de Python y se produce el error, el script se detendr\u00e1 inmediatamente, y mostrar\u00e1 un \u201ctraceback\u201d. No ejecutar\u00e1 la siguiente sentencia. He aqu\u00ed un programa de ejemplo para convertir una temperatura desde grados Fahrenheit a grados Celsius 1 : ent = input ( 'Introduzca la Temperatura Fahrenheit:' ) fahr = float ( ent ) cel = ( fahr - 32.0 ) * 5.0 / 9.0 print ( cel ) Si ejecutamos este c\u00f3digo y le damos una entrada no v\u00e1lida, simplemente fallar\u00e1 con un mensaje de error bastante antip\u00e1tico: python fahren . py Introduzca la Temperatura Fahrenheit : 72 22.2222222222 python fahren . py Introduzca la Temperatura Fahrenheit : fred Traceback ( most recent call last ): File \"fahren.py\" , line 2 , in < module > fahr = float ( ent ) ValueError : invalid literal for float (): fred Existen estructuras de ejecuci\u00f3n condicional dentro de Python para manejar este tipo de errores esperados e inesperados, llamadas try/except . La idea de try y except es que si se sabe que cierta secuencia de instrucciones puede generar un problema, sea posible a\u00f1adir ciertas sentencias para que sean ejecutadas en caso de error. Estas sentencias extras (el bloque except) ser\u00e1n ignoradas si no se produce ning\u00fan error. Pod\u00e9is pensar en la caracter\u00edstica try y except de Python como una \u201cp\u00f3liza de seguros\u201d en una secuencia de sentencias. Se puede reescribir nuestro conversor de temperaturas de esta forma: ent = input ( 'Introduzca la Temperatura Fahrenheit:' ) try : fahr = float ( ent ) cel = ( fahr - 32.0 ) * 5.0 / 9.0 print ( cel ) except : print ( 'Por favor, introduzca un n\u00famero' ) Python comienza ejecutando la secuencia de sentencias del bloque try. Si todo va bien, se saltar\u00e1 todo el bloque except y terminar\u00e1. Si ocurre una excepci\u00f3n dentro del bloque try, Python saltar\u00e1 fuera de ese bloque y ejecutar\u00e1 la secuencia de sentencias del bloque except. python fahren2 . py Introduzca la Temperatura Fahrenheit : 72 22.2222222222 python fahren2 . py Introduzca la Temperatura Fahrenheit : fred Por favor , introduzca un n\u00famero Gestionar una excepci\u00f3n con una sentencia try recibe el nombre de capturar una excepci\u00f3n. En este ejemplo, la clausula except muestra un mensaje de error. En general, capturar una excepci\u00f3n te da la oportunidad de corregir el problema, volverlo a intentar o, al menos, terminar el programa con elegancia. Nota Un buen recurso para completar el conocimiento sobre las estructuras de control es este Es especialmente interesante cuando explica los bucles y condicionales aplicados a listas, que veremos en el pr\u00f3ximo cap\u00edtulo. Coding time! Ejercicio 1 Crea un programa que solicite un n\u00famero al usuario y devuelva el siguiente mensaje: Si es mayor que 0: \"Es un n\u00famero positivo.\" Si es igual a 0: \"Es igual a cero. Si es menor que 0: \"Es un n\u00famero negativo.\" Ejemplo 1: Introduce un n\u00famero: 5 Es un n\u00famero positivo Ejemplo 2: Introduce un n\u00famero: -3 Es un n\u00famero negativo Ejercicio 2 Escribe un programa que solicite dos n\u00fameros enteros al usuario y muestre por pantalla la suma de todos los n\u00fameros enteros que hay entre los dos n\u00fameros (ambos n\u00fameros incluidos). Ejemplo 1: Introduce el n\u00famero de inicio: 4 Introduce el n\u00famero de fin: 8 El resultado es: 30 Ejemplo 2: Introduce el n\u00famero de inicio: 10 Introduce el n\u00famero de fin: 15 El resultado es: 75 Ejercicio 3 Mejora el programa anterior para que muestre por separado la suma de los n\u00fameros pares y los impares. Ejemplo 1: Introduce el n\u00famero de inicio: 4 Introduce el n\u00famero de fin: 8 Los pares suman 18 y los impares 12 Ejemplo 2: Introduce el n\u00famero de inicio: 10 Introduce el n\u00famero de fin: 15 Los pares suman 36 y los impares 39 Ejercicio 4 Escribe un programa que solicite al usuario un nombre de usuario y contrase\u00f1a. El programa mostrar\u00e1 el mensaje \"\u00a1Bienvenido!\" si el usuario introduce los siguientes datos: Nombre de usuario: root Contrase\u00f1a: toor Si los datos de acceso son incorrectos mostrar\u00e1 el mensaje \"Acceso fallido\" y el programa finalizar\u00e1. Ejemplo 1: Introduce el nombre de usuario: root Introduce la contrase\u00f1a: toor \u00a1Bienvenido! Ejemplo 2: Introduce el nombre de usuario: root Introduce la contrase\u00f1a: 123456 Acceso fallido Ejercicio 5 Mejora el programa anterior para que solo permita 3 intentos. Cada vez vez que el usuario introduzca datos de acceso incorrectos el programa mostrar\u00e1 el mensaje: \"Datos incorrectos. Le quedan X intentos.\", siendo X el n\u00famero de intentos restantes. Tras el tercer fallo el programa mostrar\u00e1 el mensaje \"Has agotado todos tus intentos.\" y finalizar\u00e1. Ejemplo: Introduce el nombre de usuario: root Introduce la contrase\u00f1a: 123456 Datos incorrectos. Le quedan 2 intentos. Introduce el nombre de usuario: root Introduce la contrase\u00f1a: abcd Datos incorrectos. Le quedan 1 intentos. Introduce el nombre de usuario: root Introduce la contrase\u00f1a: 123abc Datos incorrectos. Le quedan 0 intentos. Has agotado todos tus intentos. Ejercicio 6 Crea un programa que reciba 5 n\u00fameros del usuario y muestre el mayor de todos por pantalla. Ejemplo: Introduce un n\u00famero: 5 Introduce un n\u00famero: -10 Introduce un n\u00famero: 2 Introduce un n\u00famero: 14 Introduce un n\u00famero: 7 El n\u00famero m\u00e1s alto es: 14 Ejercicio 7 Mejora el programa anterior, de forma que el usuario pueda introducir tantos n\u00fameros como quiera. El programa solicitar\u00e1 n\u00fameros al usuario hasta que introduzca la palabra \"fin\". Entonces mostrar\u00e1 el mayor de todos por pantalla. Ejemplo: Introduce un n\u00famero: 6 Introduce un n\u00famero: 9 Introduce un n\u00famero: 11 Introduce un n\u00famero: 3 Introduce un n\u00famero: 5 Introduce un n\u00famero: fin El n\u00famero m\u00e1s alto es: 11 C\u00f3digo: https://es.py4e.com/code3/fahren2.py \u21a9","title":"Estructuras de control"},{"location":"condicionales/#estructuras-de-control","text":"","title":"Estructuras de control"},{"location":"condicionales/#condicionales","text":"Las estructuras de control se utilizan para ejecutar bloques de c\u00f3digo en funci\u00f3n de condiciones .","title":"Condicionales"},{"location":"condicionales/#sentencia-if-else","text":"Se eval\u00faa la condici\u00f3n especificada en la sentencia if y en caso de cumplirse se ejecutar\u00e1 el bloque de c\u00f3digo indentado (tabulado). En caso de que el resultado de la condici\u00f3n sea False , el bloque especificado no se ejecutar\u00e1: numero = 5 if numero > 1 : # Se ejecutar\u00e1 cuando la condici\u00f3n sea True print ( \"Es mayor que uno\" ) Las condiciones pueden tener mayor complejidad: edad = 16 altura = 175 if ( edad > 14 and altura > 160 ): print ( \"Puede montarse en la monta\u00f1a rusa\" ) Mediante la palabra reservada else es posible especificar un bloque de c\u00f3digo que se ejecute en caso de que la condici\u00f3n no se cumpla: numero = 2 if numero > 10 : # Se ejecutar\u00e1 cuando la condici\u00f3n sea True print ( \"Es mayor que diez\" ) else : # Se ejecutar\u00e1 cuando la condici\u00f3n sera False print ( \"Es menor o igual que diez\" ) Tambi\u00e9n podemos comprobar m\u00e1s condiciones mediante la expresi\u00f3n elif . En este caso, se seguir\u00e1n comprobando todas las condiciones elif hasta que una de ellas se cumpla. En caso contrario, se ejecutar\u00e1 el bloque de c\u00f3digo dentro de else (si lo hubiera). numero = 5 if numero < 3 : print ( \"Es menor que 3\" ) elif numero < 6 : print ( \"El n\u00famero est\u00e1 entre el 3 y el 5\" ) else : print ( \"Es mayor o igual a 6\" ) Tal y como muestra el siguiente c\u00f3digo de ejemplo, Python no tiene limitaciones para anidar distintos bloques de IF s. numero = 2 if numero >= 0 : if numero == 0 : print ( \"El valor es 0\" ) else : print ( \"Es un n\u00famero positivo\" ) else : print ( \"Es un n\u00famero negativo\" )","title":"Sentencia IF - ELSE"},{"location":"condicionales/#bucles","text":"Los bucles permiten ejecutar un bloque de c\u00f3digo tantas veces como queramos.","title":"Bucles"},{"location":"condicionales/#sentencia-while","text":"La sentencia while permite ejecutar un bloque de c\u00f3digo mientras la expresi\u00f3n que definamos se cumpla (es decir, devuelva True ). Python interpretar\u00e1 como True cualquier valor distinto a 0 o None . contador = 0 while ( contador < 5 ): # Se ejecutar\u00e1 mientras la variable contador sea menor a 5. contador = contador + 1 print ( \"Iteraci\u00f3n n\u00famero\" , contador ) print ( \"\u00a1Fin!\" ) Para detener una ejecuci\u00f3n de forma voluntaria se utiliza la sentencia break : contador = 0 while ( contador < 5 ): contador = contador + 1 print ( \"Iteraci\u00f3n n\u00famero\" , contador ) if contador == 3 : break print ( \"\u00a1Fin!\" ) Tambi\u00e9n es posible saltar \u00fanicamente la iteraci\u00f3n actual mediante la sentencia continue : contador = 0 while ( contador < 5 ): contador = contador + 1 if contador == 3 : continue print ( \"Iteraci\u00f3n n\u00famero {} \" . format ( contador )) print ( \"\u00a1Fin!\" ) La salida del programa anterior ser\u00e1 la siguiente: Iteraci\u00f3n n\u00famero 1 Iteraci\u00f3n n\u00famero 2 Iteraci\u00f3n n\u00famero 4 Iteraci\u00f3n n\u00famero 5 Bucle while finalizado Otros lenguajes de programaci\u00f3n ofrecen otra estructura similar conocida como DO - WHILE . No es el caso de Python, por lo que habr\u00eda que emular dicho comportamiento mediante nuestro c\u00f3digo.","title":"Sentencia WHILE"},{"location":"condicionales/#bucle-while-con-else","text":"La expresi\u00f3n else puede utilizarse tambi\u00e9n tras un bloque while . De este forma podemos definir un bloque de c\u00f3digo que se ejecutar\u00e1 una vez finalizado el bloque while (es decir, cuando la condici\u00f3n se eval\u00fae False y no se haya finalizado mediante un break ): count = 0 while ( count < 5 ): count = count + 1 print ( \"Iteraci\u00f3n n\u00famero {} \" . format ( count )) else : print ( \"Bucle while finalizado\" )","title":"Bucle WHILE con ELSE"},{"location":"condicionales/#sentencia-for","text":"A diferencia de otros lenguajes de programaci\u00f3n, en Python la sentencia FOR itera \u00fanicamente por secuencias (listas, tuplas, cadenas de caracteres,...). alumnos = [ \"Ane\" , \"Mikel\" , \"Unai\" , \"Lorea\" ] for alumno in alumnos : print ( alumno ) Tambi\u00e9n es posible utilizarlo para recorrer un string: frase = \"Aprendiendo Python\" for c in frase : print ( c ) Para detener una ejecuci\u00f3n se utiliza la sentencia break : numeros = [ 4 , 8 , 2 , 7 , 1 , 9 , 3 , 5 ] total = 0 for n in numeros : total += n if total > 10 : break Al igual que en otras estructuras de repetici\u00f3n, tambi\u00e9n es posible saltar \u00fanicamente la iteraci\u00f3n actual mediante la sentencia continue : numeros = [ 4 , 8 , 2 , 7 , 1 , 9 , 3 , 5 ] total = 0 # solo sumar los n\u00fameros impares for num in numeros : if num % 2 == 0 : print ( \"Numero par, no lo sumamos\" ) continue total += n","title":"Sentencia FOR"},{"location":"condicionales/#bucle-for-con-else","text":"Python permite definir un bloque de c\u00f3digo que se ejecutar\u00e1 una vez finalice la iteraci\u00f3n por todos los elementos de una lista. Es importante mencionar que no se ejecutar\u00e1 si se ha finalizado mediante break . alumnos = [ \"Ane\" , \"Mikel\" , \"Unai\" , \"Lorea\" ] for alumno in alumnos : print ( alumno ) else : print ( \"No quedan m\u00e1s alumnos.\" )","title":"Bucle FOR con ELSE"},{"location":"condicionales/#la-funcion-range","text":"La funci\u00f3n range([start,] stop [, step]) devuelve una secuencia de n\u00fameros. Es por ello que se utiliza de forma frecuente para iterar: for i in range ( 3 ): print ( i ) # 0 # 1 # 2 Tambi\u00e9n podemos indicar el inicio, fin y step: print ( \"N\u00fameros del 5 al 10\" ) for i in range ( 5 , 10 ): print ( i , end = ', ' ) # 5, 6, 7, 8, 9, print ( \"N\u00fameros impares del 1 al 10\" ) for i in range ( 1 , 10 , 2 ): print ( i , end = ', ' ) # 1, 3, 5, 7, 9, Para iterar por una lista utilizando el \u00edndice, basta con combinarlo con la funci\u00f3n len() : alumnos = [ \"Ane\" , \"Mikel\" , \"Unai\" , \"Lorea\" ] for i in range ( len ( alumnos )): print ( alumnos [ i ])","title":"La funci\u00f3n range()"},{"location":"condicionales/#captura-de-excepciones-usando-try-y-except","text":"Imaginemos un script donde utilicemos las funciones input e int para leer y analizar un n\u00famero entero introducido por el usuario. Resulta poco seguro realizar esta acci\u00f3n de esta forma: >>> velocidad = input ( prompt ) \u00bf Cual .... es la velocidad de vuelo de una golondrina sin carga ? \u00bf Te refieres a una golondrina africana o a una europea ? >>> int ( velocidad ) ValueError : invalid literal for int () with base 10 : >>> Cuando estamos trabajando con el int\u00e9rprete de Python, tras el error simplemente nos aparece de nuevo el prompt, as\u00ed que pensamos \u201c\u00a1epa, me he equivocado!\u201d, y continuamos con la siguiente sentencia. Sin embargo, si se escribe ese c\u00f3digo en un script de Python y se produce el error, el script se detendr\u00e1 inmediatamente, y mostrar\u00e1 un \u201ctraceback\u201d. No ejecutar\u00e1 la siguiente sentencia. He aqu\u00ed un programa de ejemplo para convertir una temperatura desde grados Fahrenheit a grados Celsius 1 : ent = input ( 'Introduzca la Temperatura Fahrenheit:' ) fahr = float ( ent ) cel = ( fahr - 32.0 ) * 5.0 / 9.0 print ( cel ) Si ejecutamos este c\u00f3digo y le damos una entrada no v\u00e1lida, simplemente fallar\u00e1 con un mensaje de error bastante antip\u00e1tico: python fahren . py Introduzca la Temperatura Fahrenheit : 72 22.2222222222 python fahren . py Introduzca la Temperatura Fahrenheit : fred Traceback ( most recent call last ): File \"fahren.py\" , line 2 , in < module > fahr = float ( ent ) ValueError : invalid literal for float (): fred Existen estructuras de ejecuci\u00f3n condicional dentro de Python para manejar este tipo de errores esperados e inesperados, llamadas try/except . La idea de try y except es que si se sabe que cierta secuencia de instrucciones puede generar un problema, sea posible a\u00f1adir ciertas sentencias para que sean ejecutadas en caso de error. Estas sentencias extras (el bloque except) ser\u00e1n ignoradas si no se produce ning\u00fan error. Pod\u00e9is pensar en la caracter\u00edstica try y except de Python como una \u201cp\u00f3liza de seguros\u201d en una secuencia de sentencias. Se puede reescribir nuestro conversor de temperaturas de esta forma: ent = input ( 'Introduzca la Temperatura Fahrenheit:' ) try : fahr = float ( ent ) cel = ( fahr - 32.0 ) * 5.0 / 9.0 print ( cel ) except : print ( 'Por favor, introduzca un n\u00famero' ) Python comienza ejecutando la secuencia de sentencias del bloque try. Si todo va bien, se saltar\u00e1 todo el bloque except y terminar\u00e1. Si ocurre una excepci\u00f3n dentro del bloque try, Python saltar\u00e1 fuera de ese bloque y ejecutar\u00e1 la secuencia de sentencias del bloque except. python fahren2 . py Introduzca la Temperatura Fahrenheit : 72 22.2222222222 python fahren2 . py Introduzca la Temperatura Fahrenheit : fred Por favor , introduzca un n\u00famero Gestionar una excepci\u00f3n con una sentencia try recibe el nombre de capturar una excepci\u00f3n. En este ejemplo, la clausula except muestra un mensaje de error. En general, capturar una excepci\u00f3n te da la oportunidad de corregir el problema, volverlo a intentar o, al menos, terminar el programa con elegancia. Nota Un buen recurso para completar el conocimiento sobre las estructuras de control es este Es especialmente interesante cuando explica los bucles y condicionales aplicados a listas, que veremos en el pr\u00f3ximo cap\u00edtulo.","title":"Captura de excepciones usando try y except"},{"location":"condicionales/#coding-time","text":"","title":"Coding time!"},{"location":"condicionales/#ejercicio-1","text":"Crea un programa que solicite un n\u00famero al usuario y devuelva el siguiente mensaje: Si es mayor que 0: \"Es un n\u00famero positivo.\" Si es igual a 0: \"Es igual a cero. Si es menor que 0: \"Es un n\u00famero negativo.\" Ejemplo 1: Introduce un n\u00famero: 5 Es un n\u00famero positivo Ejemplo 2: Introduce un n\u00famero: -3 Es un n\u00famero negativo","title":"Ejercicio 1"},{"location":"condicionales/#ejercicio-2","text":"Escribe un programa que solicite dos n\u00fameros enteros al usuario y muestre por pantalla la suma de todos los n\u00fameros enteros que hay entre los dos n\u00fameros (ambos n\u00fameros incluidos). Ejemplo 1: Introduce el n\u00famero de inicio: 4 Introduce el n\u00famero de fin: 8 El resultado es: 30 Ejemplo 2: Introduce el n\u00famero de inicio: 10 Introduce el n\u00famero de fin: 15 El resultado es: 75","title":"Ejercicio 2"},{"location":"condicionales/#ejercicio-3","text":"Mejora el programa anterior para que muestre por separado la suma de los n\u00fameros pares y los impares. Ejemplo 1: Introduce el n\u00famero de inicio: 4 Introduce el n\u00famero de fin: 8 Los pares suman 18 y los impares 12 Ejemplo 2: Introduce el n\u00famero de inicio: 10 Introduce el n\u00famero de fin: 15 Los pares suman 36 y los impares 39","title":"Ejercicio 3"},{"location":"condicionales/#ejercicio-4","text":"Escribe un programa que solicite al usuario un nombre de usuario y contrase\u00f1a. El programa mostrar\u00e1 el mensaje \"\u00a1Bienvenido!\" si el usuario introduce los siguientes datos: Nombre de usuario: root Contrase\u00f1a: toor Si los datos de acceso son incorrectos mostrar\u00e1 el mensaje \"Acceso fallido\" y el programa finalizar\u00e1. Ejemplo 1: Introduce el nombre de usuario: root Introduce la contrase\u00f1a: toor \u00a1Bienvenido! Ejemplo 2: Introduce el nombre de usuario: root Introduce la contrase\u00f1a: 123456 Acceso fallido","title":"Ejercicio 4"},{"location":"condicionales/#ejercicio-5","text":"Mejora el programa anterior para que solo permita 3 intentos. Cada vez vez que el usuario introduzca datos de acceso incorrectos el programa mostrar\u00e1 el mensaje: \"Datos incorrectos. Le quedan X intentos.\", siendo X el n\u00famero de intentos restantes. Tras el tercer fallo el programa mostrar\u00e1 el mensaje \"Has agotado todos tus intentos.\" y finalizar\u00e1. Ejemplo: Introduce el nombre de usuario: root Introduce la contrase\u00f1a: 123456 Datos incorrectos. Le quedan 2 intentos. Introduce el nombre de usuario: root Introduce la contrase\u00f1a: abcd Datos incorrectos. Le quedan 1 intentos. Introduce el nombre de usuario: root Introduce la contrase\u00f1a: 123abc Datos incorrectos. Le quedan 0 intentos. Has agotado todos tus intentos.","title":"Ejercicio 5"},{"location":"condicionales/#ejercicio-6","text":"Crea un programa que reciba 5 n\u00fameros del usuario y muestre el mayor de todos por pantalla. Ejemplo: Introduce un n\u00famero: 5 Introduce un n\u00famero: -10 Introduce un n\u00famero: 2 Introduce un n\u00famero: 14 Introduce un n\u00famero: 7 El n\u00famero m\u00e1s alto es: 14","title":"Ejercicio 6"},{"location":"condicionales/#ejercicio-7","text":"Mejora el programa anterior, de forma que el usuario pueda introducir tantos n\u00fameros como quiera. El programa solicitar\u00e1 n\u00fameros al usuario hasta que introduzca la palabra \"fin\". Entonces mostrar\u00e1 el mayor de todos por pantalla. Ejemplo: Introduce un n\u00famero: 6 Introduce un n\u00famero: 9 Introduce un n\u00famero: 11 Introduce un n\u00famero: 3 Introduce un n\u00famero: 5 Introduce un n\u00famero: fin El n\u00famero m\u00e1s alto es: 11 C\u00f3digo: https://es.py4e.com/code3/fahren2.py \u21a9","title":"Ejercicio 7"},{"location":"diccionarios/","text":"Diccionarios Un diccionario es un conjunto de parejas clave- valor (key-value). Es decir, se accede a cada elemento a partir de su clave. Se definen de la siguiente manera: estudiante = { \"nombre\" : \"Mart\u00ed Maci\u00e0\" , \"edad\" : 30 , \"nota_media\" : 7.25 , \"repetidor\" : False } Las claves tienen que ser \u00fanicas y estar formadas por un string o un n\u00famero . Para acceder al valor de una clave existen dos maneras distintas: # Acceder al valor de una clave edad = estudiante [ \"edad\" ] # devuelve el valor de 'edad' nota_media = estudiante . get ( \"nota_media\" ) # devuelve el valor de 'nota_media' # Insertar o actualizar un valor: estudiante [ \"edad\" ] = 25 # actualiza el valor de 'edad' estudiante [ \"suspensos\" ] = 3 # inserta una nueva pareja clave - valor # insertar una pareja clave - valor o actualizar si ya existe: estudiante . update ({ 'aprobados' : '8' }) Algunos de los m\u00e9todos m\u00e1s utilizados son los siguientes: M\u00e9todo Acci\u00f3n diccionario.keys() Devuelve todas las claves del diccionario diccionario.values() Devuelve todos los valores del diccionario diccionario.pop(clave[,<default>]) Elimina la clave del diccionario y devuelve su valor asociado. Si no la encuentra y se indica un valor por defecto, devuelve el valor por defecto indicado. diccionario.clear() Vac\u00eda el diccionario clave in diccionario Devuelve True si el diccionario contiene la clave o False en caso contrario. valor in diccionario.values() Devuelve True si el diccionario contiene el valor o False en caso contrario. Recorrer un diccionario La forma m\u00e1s habitual de recorrer un diccionario es mediante la sentencia for . Al recorrer un diccionario, por defecto se iterar\u00e1 sobre sus claves: diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in diccionario : print ( key ) # Resultado: a b c Es decir, el c\u00f3digo anterior ser\u00e1 equivalente al siguiente: diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in diccionario . keys (): print ( key ) # Resultado: a b c Por lo tanto, para iterar accediendo a los valores, realizaremos lo siguiente: diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in diccionario : print ( diccionario [ key ]) # Resultado: 1 2 3 Otro manera alternativa ser\u00eda empleando la funci\u00f3n items() , la cual devuelve el diccionario como tuplas de tipo (key,value): diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key , value in diccionario . items (): print ( \"El valor de %s is %d \" % ( key , value )) # Resultado: # El valor de a is 1 # El valor de b is 2 # El valor de c is 3 Borrar un elemento Para borrar un elemento de un diccionario se utiliza la instrucci\u00f3n del . edades = { \"Ana\" : 22 , \"Jordi\" : 27 , \"Aitor\" : 15 } del edades [ \"Aitor\" ] Otra alternativa tambi\u00e9n utilizada y mencionada anteriormente es la funci\u00f3n pop() , el cual devuelve el valor del elemento eliminado: edades = { \"Ana\" : 22 , \"Jordi\" : 27 , \"Aitor\" : 15 } edades . pop ( \"Aitor\" ) Un diccionario nunca deber\u00eda contener dos claves iguales. No obstante, en caso de contener una clave repetida, tanto del como pop() eliminar\u00e1n todas las claves coincidentes. Diccionario como un conjunto de contadores Supongamos que recibes una cadena y quieres contar cu\u00e1ntas veces aparece cada letra. Hay varias formas de hacerlo: Puedes crear 26 variables, una por cada letra del alfabeto. Luego puedes recorrer la cadena, y para cada caracter, incrementar el contador correspondiente, probablemente utilizando varios condicionales. Puedes crear una lista con 26 elementos. Despu\u00e9s podr\u00edas convertir cada caracter en un n\u00famero (usando la funci\u00f3n interna ord ), usar el n\u00famero como \u00edndice dentro de la lista, e incrementar el contador correspondiente. Puedes crear un diccionario con caracteres como claves y contadores como los valores correspondientes. La primera vez que encuentres un caracter, agregar\u00edas un elemento al diccionario. Despu\u00e9s de eso incrementar\u00edas el valor del elemento existente. Cada una de esas opciones realiza la misma operaci\u00f3n computacional, pero cada una de ellas implementa esa operaci\u00f3n de forma diferente. Una implementaci\u00f3n es una forma de llevar a cabo una operaci\u00f3n computacional; algunas implementaciones son mejores que otras. Por ejemplo, una ventaja de la implementaci\u00f3n del diccionario es que no tenemos que saber con antelaci\u00f3n qu\u00e9 letras aparecen en la cadena y solamente necesitamos espacio para las letras que s\u00ed aparecen. Aqu\u00ed est\u00e1 un ejemplo de como ser\u00eda ese c\u00f3digo: palabra = 'brontosaurio' d = dict () for c in palabra : if c not in d : d [ c ] = 1 else : d [ c ] = d [ c ] + 1 print ( d ) Realmente estamos calculando un histograma, el cual es un t\u00e9rmino estad\u00edstico para un conjunto de contadores (o frecuencias). El bucle for recorre la cadena. Cada vez que entramos al bucle, si el caracter c no est\u00e1 en el diccionario, creamos un nuevo elemento con la clave c y el valor inicial 1 (debido a que hemos visto esta letra solo una vez). Si c ya est\u00e1 previamente en el diccionario incrementamos d[c]. Aqu\u00ed est\u00e1 la salida del programa: { 'b' : 1 , 'r' : 2 , 'o' : 3 , 'n' : 1 , 't' : 1 , 's' : 1 , 'a' : 1 , 'u' : 1 , 'i' : 1 } El histograma indica que las letras \u201ca\u201d y \u201cb\u201d aparecen solo una vez; \u201co\u201d aparece dos, y as\u00ed sucesivamente. Los diccionarios tienen un m\u00e9todo llamado get que toma una clave y un valor por defecto. Si la clave aparece en el diccionario, get regresa el valor correspondiente; sino, devuelve el valor por defecto. Por ejemplo: >>> cuentas = { 'chuck' : 1 , 'annie' : 42 , 'jan' : 100 } >>> print ( cuentas . get ( 'jan' , 0 )) 100 >>> print ( cuentas . get ( 'tim' , 0 )) 0 Podemos usar get para escribir nuestro bucle de histograma m\u00e1s conciso. Puesto que el m\u00e9todo get autom\u00e1ticamente maneja el caso en que una clave no est\u00e1 en el diccionario, podemos reducir cuatro l\u00edneas a una y eliminar la sentencia if . palabra = 'brontosaurio' d = dict () for c in palabra : d [ c ] = d . get ( c , 0 ) + 1 print ( d ) El uso del m\u00e9todo get para simplificar este bucle contador termina siendo un \u201cidioma\u201d muy utilizado en Python. Tom\u00e1os un momento para comparar el bucle utilizando la sentencia if y el operador in con el bucle utilizando el m\u00e9todo get . Ambos hacen exactamente lo mismo, pero uno es m\u00e1s breve. Nota Para completar todo lo relativo a diccionarios y descubrir el concepto de nesting (diccionarios de listas, listas de diccionarios, diccionarios dentro de diccionarios...), pod\u00e9is consultar esta parte de este cap\u00edtulo . Coding time! Ejercicio 1 Crea un programa que recorra una lista y cree un diccionario que contenga el n\u00famero de veces que aparece cada n\u00famero en la lista. - Ejemplo: [12, 23, 5, 12, 92, 5,12, 5, 29, 92, 64,23] - Resultado: {12: 3, 23: 2, 5: 3, 92: 2, 29: 1, 64: 1} Ejercicio 2 Recorre un diccionario y crea una lista solo con los valores que contiene, sin a\u00f1adir valores duplicados. - Ejemplo: {'Mikel': 3, 'Ana': 8, 'Amaia': 12, 'Unai': 5, 'Jon': 8, 'Ainhoa': 7, 'Maite': 5} - Resultado: [3, 8, 12, 5, 7] Ejercicio 3 Crea una programa de Login que compruebe el usuario y contrase\u00f1a en el diccionario a continuaci\u00f3n: usuarios = { \"mmacia\" : { \"nombre\" : \"Mart\u00ed\" , \"apellido\" : \"Maci\u00e0\" , \"password\" : \"123123\" }, \"fmuguruza\" : { \"nombre\" : \"Ferm\u00edn\" , \"apellido\" : \"Muguruza\" , \"password\" : \"654321\" }, \"cbiriukov\" : { \"nombre\" : \"Chechu\" , \"apellido\" : \"Biriukov\" , \"password\" : \"123456\" } } El usuario tendr\u00e1 un m\u00e1ximo de 3 intentos, y al acceder correctamente se mostrar\u00e1 el nombre y apellido del usuario. Ejercicio 4 Crea un programa que permita introducir a un profesor las notas de sus estudiantes (m\u00e1ximo 10 estudiantes). Los datos se deber\u00e1n almacenar en un diccionario como el siguiente: estudiantes = { \"1\" : { \"nombre\" : \"Lorena\" , \"nota\" : 8 }, \"2\" : { \"nombre\" : \"Marcel\" , \"nota\" : \"4.2\" }, \"3\" : { \"nombre\" : \"Julio\" , \"nota\" : 6.5 } } Una vez introducidos todos los datos, el programa mostrar\u00e1 una lista con los nombres de los estudiantes que han suspendido y otra con los que han aprobado. Tambi\u00e9n calcular\u00e1 y mostrar\u00e1 la nota media de la clase.","title":"Diccionarios"},{"location":"diccionarios/#diccionarios","text":"Un diccionario es un conjunto de parejas clave- valor (key-value). Es decir, se accede a cada elemento a partir de su clave. Se definen de la siguiente manera: estudiante = { \"nombre\" : \"Mart\u00ed Maci\u00e0\" , \"edad\" : 30 , \"nota_media\" : 7.25 , \"repetidor\" : False } Las claves tienen que ser \u00fanicas y estar formadas por un string o un n\u00famero . Para acceder al valor de una clave existen dos maneras distintas: # Acceder al valor de una clave edad = estudiante [ \"edad\" ] # devuelve el valor de 'edad' nota_media = estudiante . get ( \"nota_media\" ) # devuelve el valor de 'nota_media' # Insertar o actualizar un valor: estudiante [ \"edad\" ] = 25 # actualiza el valor de 'edad' estudiante [ \"suspensos\" ] = 3 # inserta una nueva pareja clave - valor # insertar una pareja clave - valor o actualizar si ya existe: estudiante . update ({ 'aprobados' : '8' }) Algunos de los m\u00e9todos m\u00e1s utilizados son los siguientes: M\u00e9todo Acci\u00f3n diccionario.keys() Devuelve todas las claves del diccionario diccionario.values() Devuelve todos los valores del diccionario diccionario.pop(clave[,<default>]) Elimina la clave del diccionario y devuelve su valor asociado. Si no la encuentra y se indica un valor por defecto, devuelve el valor por defecto indicado. diccionario.clear() Vac\u00eda el diccionario clave in diccionario Devuelve True si el diccionario contiene la clave o False en caso contrario. valor in diccionario.values() Devuelve True si el diccionario contiene el valor o False en caso contrario.","title":"Diccionarios"},{"location":"diccionarios/#recorrer-un-diccionario","text":"La forma m\u00e1s habitual de recorrer un diccionario es mediante la sentencia for . Al recorrer un diccionario, por defecto se iterar\u00e1 sobre sus claves: diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in diccionario : print ( key ) # Resultado: a b c Es decir, el c\u00f3digo anterior ser\u00e1 equivalente al siguiente: diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in diccionario . keys (): print ( key ) # Resultado: a b c Por lo tanto, para iterar accediendo a los valores, realizaremos lo siguiente: diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in diccionario : print ( diccionario [ key ]) # Resultado: 1 2 3 Otro manera alternativa ser\u00eda empleando la funci\u00f3n items() , la cual devuelve el diccionario como tuplas de tipo (key,value): diccionario = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key , value in diccionario . items (): print ( \"El valor de %s is %d \" % ( key , value )) # Resultado: # El valor de a is 1 # El valor de b is 2 # El valor de c is 3","title":"Recorrer un diccionario"},{"location":"diccionarios/#borrar-un-elemento","text":"Para borrar un elemento de un diccionario se utiliza la instrucci\u00f3n del . edades = { \"Ana\" : 22 , \"Jordi\" : 27 , \"Aitor\" : 15 } del edades [ \"Aitor\" ] Otra alternativa tambi\u00e9n utilizada y mencionada anteriormente es la funci\u00f3n pop() , el cual devuelve el valor del elemento eliminado: edades = { \"Ana\" : 22 , \"Jordi\" : 27 , \"Aitor\" : 15 } edades . pop ( \"Aitor\" ) Un diccionario nunca deber\u00eda contener dos claves iguales. No obstante, en caso de contener una clave repetida, tanto del como pop() eliminar\u00e1n todas las claves coincidentes.","title":"Borrar un elemento"},{"location":"diccionarios/#diccionario-como-un-conjunto-de-contadores","text":"Supongamos que recibes una cadena y quieres contar cu\u00e1ntas veces aparece cada letra. Hay varias formas de hacerlo: Puedes crear 26 variables, una por cada letra del alfabeto. Luego puedes recorrer la cadena, y para cada caracter, incrementar el contador correspondiente, probablemente utilizando varios condicionales. Puedes crear una lista con 26 elementos. Despu\u00e9s podr\u00edas convertir cada caracter en un n\u00famero (usando la funci\u00f3n interna ord ), usar el n\u00famero como \u00edndice dentro de la lista, e incrementar el contador correspondiente. Puedes crear un diccionario con caracteres como claves y contadores como los valores correspondientes. La primera vez que encuentres un caracter, agregar\u00edas un elemento al diccionario. Despu\u00e9s de eso incrementar\u00edas el valor del elemento existente. Cada una de esas opciones realiza la misma operaci\u00f3n computacional, pero cada una de ellas implementa esa operaci\u00f3n de forma diferente. Una implementaci\u00f3n es una forma de llevar a cabo una operaci\u00f3n computacional; algunas implementaciones son mejores que otras. Por ejemplo, una ventaja de la implementaci\u00f3n del diccionario es que no tenemos que saber con antelaci\u00f3n qu\u00e9 letras aparecen en la cadena y solamente necesitamos espacio para las letras que s\u00ed aparecen. Aqu\u00ed est\u00e1 un ejemplo de como ser\u00eda ese c\u00f3digo: palabra = 'brontosaurio' d = dict () for c in palabra : if c not in d : d [ c ] = 1 else : d [ c ] = d [ c ] + 1 print ( d ) Realmente estamos calculando un histograma, el cual es un t\u00e9rmino estad\u00edstico para un conjunto de contadores (o frecuencias). El bucle for recorre la cadena. Cada vez que entramos al bucle, si el caracter c no est\u00e1 en el diccionario, creamos un nuevo elemento con la clave c y el valor inicial 1 (debido a que hemos visto esta letra solo una vez). Si c ya est\u00e1 previamente en el diccionario incrementamos d[c]. Aqu\u00ed est\u00e1 la salida del programa: { 'b' : 1 , 'r' : 2 , 'o' : 3 , 'n' : 1 , 't' : 1 , 's' : 1 , 'a' : 1 , 'u' : 1 , 'i' : 1 } El histograma indica que las letras \u201ca\u201d y \u201cb\u201d aparecen solo una vez; \u201co\u201d aparece dos, y as\u00ed sucesivamente. Los diccionarios tienen un m\u00e9todo llamado get que toma una clave y un valor por defecto. Si la clave aparece en el diccionario, get regresa el valor correspondiente; sino, devuelve el valor por defecto. Por ejemplo: >>> cuentas = { 'chuck' : 1 , 'annie' : 42 , 'jan' : 100 } >>> print ( cuentas . get ( 'jan' , 0 )) 100 >>> print ( cuentas . get ( 'tim' , 0 )) 0 Podemos usar get para escribir nuestro bucle de histograma m\u00e1s conciso. Puesto que el m\u00e9todo get autom\u00e1ticamente maneja el caso en que una clave no est\u00e1 en el diccionario, podemos reducir cuatro l\u00edneas a una y eliminar la sentencia if . palabra = 'brontosaurio' d = dict () for c in palabra : d [ c ] = d . get ( c , 0 ) + 1 print ( d ) El uso del m\u00e9todo get para simplificar este bucle contador termina siendo un \u201cidioma\u201d muy utilizado en Python. Tom\u00e1os un momento para comparar el bucle utilizando la sentencia if y el operador in con el bucle utilizando el m\u00e9todo get . Ambos hacen exactamente lo mismo, pero uno es m\u00e1s breve. Nota Para completar todo lo relativo a diccionarios y descubrir el concepto de nesting (diccionarios de listas, listas de diccionarios, diccionarios dentro de diccionarios...), pod\u00e9is consultar esta parte de este cap\u00edtulo .","title":"Diccionario como un conjunto de contadores"},{"location":"diccionarios/#coding-time","text":"","title":"Coding time!"},{"location":"diccionarios/#ejercicio-1","text":"Crea un programa que recorra una lista y cree un diccionario que contenga el n\u00famero de veces que aparece cada n\u00famero en la lista. - Ejemplo: [12, 23, 5, 12, 92, 5,12, 5, 29, 92, 64,23] - Resultado: {12: 3, 23: 2, 5: 3, 92: 2, 29: 1, 64: 1}","title":"Ejercicio 1"},{"location":"diccionarios/#ejercicio-2","text":"Recorre un diccionario y crea una lista solo con los valores que contiene, sin a\u00f1adir valores duplicados. - Ejemplo: {'Mikel': 3, 'Ana': 8, 'Amaia': 12, 'Unai': 5, 'Jon': 8, 'Ainhoa': 7, 'Maite': 5} - Resultado: [3, 8, 12, 5, 7]","title":"Ejercicio 2"},{"location":"diccionarios/#ejercicio-3","text":"Crea una programa de Login que compruebe el usuario y contrase\u00f1a en el diccionario a continuaci\u00f3n: usuarios = { \"mmacia\" : { \"nombre\" : \"Mart\u00ed\" , \"apellido\" : \"Maci\u00e0\" , \"password\" : \"123123\" }, \"fmuguruza\" : { \"nombre\" : \"Ferm\u00edn\" , \"apellido\" : \"Muguruza\" , \"password\" : \"654321\" }, \"cbiriukov\" : { \"nombre\" : \"Chechu\" , \"apellido\" : \"Biriukov\" , \"password\" : \"123456\" } } El usuario tendr\u00e1 un m\u00e1ximo de 3 intentos, y al acceder correctamente se mostrar\u00e1 el nombre y apellido del usuario.","title":"Ejercicio 3"},{"location":"diccionarios/#ejercicio-4","text":"Crea un programa que permita introducir a un profesor las notas de sus estudiantes (m\u00e1ximo 10 estudiantes). Los datos se deber\u00e1n almacenar en un diccionario como el siguiente: estudiantes = { \"1\" : { \"nombre\" : \"Lorena\" , \"nota\" : 8 }, \"2\" : { \"nombre\" : \"Marcel\" , \"nota\" : \"4.2\" }, \"3\" : { \"nombre\" : \"Julio\" , \"nota\" : 6.5 } } Una vez introducidos todos los datos, el programa mostrar\u00e1 una lista con los nombres de los estudiantes que han suspendido y otra con los que han aprobado. Tambi\u00e9n calcular\u00e1 y mostrar\u00e1 la nota media de la clase.","title":"Ejercicio 4"},{"location":"excepciones/","text":"Excepciones Las excepciones son errores en la ejecuci\u00f3n de un programa que hacen que el programa termine de forma inesperada. Normalmente ocurren debido a un uso indebido de los datos (p.ej. una divisi\u00f3n entre cero). La manera de controlar las excepciones es agrupando el c\u00f3digo en 2 bloques (m\u00e1s 1 opcional): try : agrupa el bloque de c\u00f3digo en el que se pueda dar una excepci\u00f3n. catch : contiene el c\u00f3digo a ejecutar en caso de que la excepci\u00f3n haya sido lanzada. finally (opcional): permite ejecutar un bloque de c\u00f3digo siempre, se haya capturado o no una excepci\u00f3n. try : numero = int ( input ( \u2018 Introduce un n\u00famero : \u2018 )) dividendo = 150 resultado = dividendo / numero print ( resultado ) except ValueError : print ( \u2018 N\u00famero inv\u00e1lido \u2019 ) except ZeroDivisionError : print ( \u2018 No se puede dividir entre 0 \u2019 ) finally : print ( \"Ejecutando finally antes de salir\" ) Tambi\u00e9n es posible lanzar excepciones de forma controlada mediante la sentencia raise. raise NameError ( '\u00a1Soy una excepci\u00f3n!' ) Excepciones comunes Hay algunas excepciones que son bastante comunes a la hora de programar en Python y que deber\u00edamos contemplar en nuestros programas: TypeError es lanzado cuando se intenta realizar una operaci\u00f3n o una funci\u00f3n sobre un objeto de un tipo inapropiado. >>> '1'+1 Traceback (most recent call last): File \"<pyshell#23>\", line 1, in <module> '2'+2 TypeError: must be str, not int ValueError es lanzado cuando el argumento de una funci\u00f3n es de un tipo inapropiado. >>> int('hola') Traceback (most recent call last): File \"<pyshell#14>\", line 1, in <module> int('xyz') ValueError: invalid literal for int() with base 10: 'hola' NameError es lanzado cuando no utiliza un objeto que no existe. >>> persona Traceback (most recent call last): File \"<pyshell#6>\", line 1, in <module> age NameError: name 'persona' is not defined IndexError es lanzado al intentar acceder a un \u00edndice que no existe en un array. >>> lista = [1,2,3] >>> lista[5] Traceback (most recent call last): File \"<pyshell#18>\", line 1, in <module> lista[5] IndexError: list index out of range KeyError es lanzado cuando no se encuentra la clave (key), >>> diccionario={'1':\"esto\", '2':\"es\", '3':\"python\"} >>> diccionario['4'] Traceback (most recent call last): File \"<pyshell#15>\", line 1, in <module> diccionario['4'] KeyError: '4' ModuleNotFoundError es lanzado cuando no se encuentra el m\u00f3dulo indicado. >>> import mimodulo Traceback (most recent call last): File \"<pyshell#10>\", line 1, in <module> import mimodulo ModuleNotFoundError: No module named 'mimodulo' Coding time! Ejercicio 1 Crea un programa que acceda a la posici\u00f3n que el usuario indique de la siguiente lista: [6,14,11,3,2,1,15,19] . No olvides capturar las excepciones que puedan surgir en caso de que el usuario introduzca un \u00edndice incorrecto o que no exista en la lista. Ejercicio 2 Crea una aplicaci\u00f3n reciba la clave de un diccionario y acceda a uno de sus valores. Aseg\u00farate de que capturas las excepciones que puedan saltar al intentar acceder a una clave del diccionario inexistente.","title":"Excepciones"},{"location":"excepciones/#excepciones","text":"Las excepciones son errores en la ejecuci\u00f3n de un programa que hacen que el programa termine de forma inesperada. Normalmente ocurren debido a un uso indebido de los datos (p.ej. una divisi\u00f3n entre cero). La manera de controlar las excepciones es agrupando el c\u00f3digo en 2 bloques (m\u00e1s 1 opcional): try : agrupa el bloque de c\u00f3digo en el que se pueda dar una excepci\u00f3n. catch : contiene el c\u00f3digo a ejecutar en caso de que la excepci\u00f3n haya sido lanzada. finally (opcional): permite ejecutar un bloque de c\u00f3digo siempre, se haya capturado o no una excepci\u00f3n. try : numero = int ( input ( \u2018 Introduce un n\u00famero : \u2018 )) dividendo = 150 resultado = dividendo / numero print ( resultado ) except ValueError : print ( \u2018 N\u00famero inv\u00e1lido \u2019 ) except ZeroDivisionError : print ( \u2018 No se puede dividir entre 0 \u2019 ) finally : print ( \"Ejecutando finally antes de salir\" ) Tambi\u00e9n es posible lanzar excepciones de forma controlada mediante la sentencia raise. raise NameError ( '\u00a1Soy una excepci\u00f3n!' )","title":"Excepciones"},{"location":"excepciones/#excepciones-comunes","text":"Hay algunas excepciones que son bastante comunes a la hora de programar en Python y que deber\u00edamos contemplar en nuestros programas: TypeError es lanzado cuando se intenta realizar una operaci\u00f3n o una funci\u00f3n sobre un objeto de un tipo inapropiado. >>> '1'+1 Traceback (most recent call last): File \"<pyshell#23>\", line 1, in <module> '2'+2 TypeError: must be str, not int ValueError es lanzado cuando el argumento de una funci\u00f3n es de un tipo inapropiado. >>> int('hola') Traceback (most recent call last): File \"<pyshell#14>\", line 1, in <module> int('xyz') ValueError: invalid literal for int() with base 10: 'hola' NameError es lanzado cuando no utiliza un objeto que no existe. >>> persona Traceback (most recent call last): File \"<pyshell#6>\", line 1, in <module> age NameError: name 'persona' is not defined IndexError es lanzado al intentar acceder a un \u00edndice que no existe en un array. >>> lista = [1,2,3] >>> lista[5] Traceback (most recent call last): File \"<pyshell#18>\", line 1, in <module> lista[5] IndexError: list index out of range KeyError es lanzado cuando no se encuentra la clave (key), >>> diccionario={'1':\"esto\", '2':\"es\", '3':\"python\"} >>> diccionario['4'] Traceback (most recent call last): File \"<pyshell#15>\", line 1, in <module> diccionario['4'] KeyError: '4' ModuleNotFoundError es lanzado cuando no se encuentra el m\u00f3dulo indicado. >>> import mimodulo Traceback (most recent call last): File \"<pyshell#10>\", line 1, in <module> import mimodulo ModuleNotFoundError: No module named 'mimodulo'","title":"Excepciones comunes"},{"location":"excepciones/#coding-time","text":"","title":"Coding time!"},{"location":"excepciones/#ejercicio-1","text":"Crea un programa que acceda a la posici\u00f3n que el usuario indique de la siguiente lista: [6,14,11,3,2,1,15,19] . No olvides capturar las excepciones que puedan surgir en caso de que el usuario introduzca un \u00edndice incorrecto o que no exista en la lista.","title":"Ejercicio 1"},{"location":"excepciones/#ejercicio-2","text":"Crea una aplicaci\u00f3n reciba la clave de un diccionario y acceda a uno de sus valores. Aseg\u00farate de que capturas las excepciones que puedan saltar al intentar acceder a una clave del diccionario inexistente.","title":"Ejercicio 2"},{"location":"funciones/","text":"Funciones Una funci\u00f3n es un grupo de sentencias que realizan una tarea concreta. Esta forma de agrupar c\u00f3digo es una forma de ordenar nuestra aplicaci\u00f3n en peque\u00f1os bloques, facilitando as\u00ed su lectura y permitiendo reutilizar el c\u00f3digo que contienen sin esfuerzo. Definir y llamar a una funci\u00f3n La sintaxis de una funci\u00f3n en Python es la siguiente: def saludo ( nombre ): # codigo de la funci\u00f3n print ( \"Hola, \" + nombre + \". \u00a1Bienvenido!\" ) Se escribe la palabra reservada def seguida del nombre de la funci\u00f3n y sus par\u00e1metros entre par\u00e9ntesis. Para llamar a una funci\u00f3n solo hay que escribir el nombre de la funci\u00f3n seguida de los par\u00e1metros (si los hubiera) entre par\u00e9ntesis. >>> saludo ( 'Maitane' ) Hola , Maitane . \u00a1 Bienvenida ! Es posible asignar al par\u00e1metro un valor por defecto . def saludo ( nombre = \"An\u00f3nimo\" ): print ( \"Hola, \" + nombre + \". \u00a1Bienvenido!\" ) saludo ( \"Leire\" ) # Hola, Maitane. \u00a1Bienvenida! saludo () # Hola, An\u00f3nimo. \u00a1Bienvenida! Existen dos tipos de par\u00e1metros o argumentos: Par\u00e1metros posicionales : la posici\u00f3n en la que se pasan importa Par\u00e1metros con palabra clave (keyword arguments) : la posici\u00f3n no importa, se indica una clave para cada par\u00e1metro. def suma ( a , b ): resultado = a + b print ( resultado ) suma ( 45 , 20 ) # par\u00e1metros posicionales suma ( b = 20 , a = 45 ) # parametros mediante clave Las funciones pueden devolver un valor utilizando la palabra return . Una vez devuelto un valor, la funci\u00f3n finaliza su ejecuci\u00f3n. def suma ( a , b ): resultado = a + b return resultado print ( suma ( 4 , 5 )) # 9 Funciones con argumentos m\u00faltiples Es posible recibir un n\u00famero desconocido de par\u00e1metros a\u00f1adiendo un * en la definici\u00f3n de la funci\u00f3n. def suma_todo ( * args ): resultado = 0 for i in args : resultado += i return resultado v , w , x , y , z = 5 , 2 , 12 , 6 , 9 total = suma_todo ( v , w , x , y , z ) print ( \"La suma total es:\" + str ( total )) # La suma total es: 34 \u00c1mbito de las variables (scope) El \u00e1mbito de una variable ( scope ) se refiere a la zona del programa d\u00f3nde una variable \"existe\". Fuera del \u00e1mbito de una variable no podremos acceder a su valor ni manejarla. Los par\u00e1metros y variables definidos en una funci\u00f3n no estar\u00e1n accesibles fuera de la funci\u00f3n. A este \u00e1mbito se le conoce como \u00e1mbito local . Es importante mencionar que una vez ejecutada una funci\u00f3n, el valor de las variables locales no se almacena, por lo que la pr\u00f3xima vez que se llame a la funci\u00f3n, \u00e9sta no recordar\u00e1 ning\u00fan valor de llamadas anteriores. def calcula (): a = 1 print ( \"Dentro de la funci\u00f3n:\" , a ) a = 5 calcula () print ( \"Fuera de la funci\u00f3n:\" , a ) ### Output ### # Dentro de la funci\u00f3n:1 # Fuera de la funci\u00f3n:5 Por el contrario, las variables definidas fuera de una funci\u00f3n s\u00ed que est\u00e1n accesibles desde dentro de la funci\u00f3n. Se considera que est\u00e1n en el \u00e1mbito global . No obstante, no se podr\u00e1n modificar dentro de la funci\u00f3n a no ser que est\u00e9n definidas con la palabra clave global . Funciones internas Python proporciona un n\u00famero importante de funciones denominadas built-in o internas, que pueden ser usadas sin necesidad de tener que definirlas previamente. Los creadores de Python han escrito este conjunto de funciones para resolver problemas comunes y las han incluido en Python para que las podamos utilizar. Un ejemplo son las funciones max y min nos dar\u00e1n respectivamente el valor mayor y menor de una lista. Dependiendo de la versi\u00f3n de Python utilizada, la lista podr\u00e1 diferir. Para Python 3.10.6 estas funciones son: Y el funcionamiento de cada una de ellas puede consultarse aqu\u00ed . \u00bfPor qu\u00e9 necesitamos las funciones? Puede no estar muy claro por qu\u00e9 merece la pena molestarse en dividir un programa en funciones. Existen varias razones: El crear una funci\u00f3n nueva te da la oportunidad de dar nombre a un grupo de sentencias, lo cual hace tu programa m\u00e1s f\u00e1cil de leer, entender y depurar. Las funciones pueden hacer un programa m\u00e1s peque\u00f1o, al eliminar c\u00f3digo repetido. Adem\u00e1s, si quieres realizar cualquier cambio en el futuro, s\u00f3lo tendr\u00e1s que hacerlo en un \u00fanico lugar. Dividir un programa largo en funciones te permite depurar las partes de una en una y luego ensamblarlas juntas en una sola pieza. Las funciones bien dise\u00f1adas a menudo resultan \u00fatiles para otros muchos programas. Una vez que has escrito y depurado una, puedes reutilizarla. Parte de la habilidad de crear y usar funciones consiste en llegar a tener una funci\u00f3n que represente correctamente una idea, como \u201cencontrar el valor m\u00e1s peque\u00f1o en una lista de valores\u201d, por ejemplo. Coding time! Ejercicio 1 Crea un programa que determine si un n\u00famero es primo o no. Deber\u00e1s crear la funci\u00f3n esPrimo() que reciba como par\u00e1metro un n\u00famero y devuelva True o False indicando si el n\u00famero es primo o no. Ejercicio 2 Crea un programa que genere un n\u00famero aleatorio del 1 al 10. El usuario tendr\u00e1 que adivinarlo, y el programa tras cada intento le indicar\u00e1 al usuario si el n\u00famero es m\u00e1s alto, bajo o si ha acertado. La l\u00f3gica para dar la respuesta al usuario deber\u00e1 estar incluida en una funci\u00f3n a la que se llamar\u00e1 tras cada intento. Nota: Para la creaci\u00f3n del n\u00famero aleatorio, utiliza el siguiente c\u00f3digo: from random import randint , uniform , random numero = randint ( 0 , 10 ) Ejercicio 3 Crea un programa que reciba un n\u00famero del 1 al 20 introducido por el usuario y compruebe si est\u00e1 dentro de la siguiente lista: [6,14,11,3,2,1,15,19] . Implementa una funci\u00f3n que se asegure que el n\u00famero introducido por el usuario est\u00e1 en el rango indicado y otra que compruebe si est\u00e1 dentro de la lista. Trata de crear las funciones de forma que puedan ser reutilizadas lo m\u00e1ximo posible en otros programas.","title":"Funciones"},{"location":"funciones/#funciones","text":"Una funci\u00f3n es un grupo de sentencias que realizan una tarea concreta. Esta forma de agrupar c\u00f3digo es una forma de ordenar nuestra aplicaci\u00f3n en peque\u00f1os bloques, facilitando as\u00ed su lectura y permitiendo reutilizar el c\u00f3digo que contienen sin esfuerzo.","title":"Funciones"},{"location":"funciones/#definir-y-llamar-a-una-funcion","text":"La sintaxis de una funci\u00f3n en Python es la siguiente: def saludo ( nombre ): # codigo de la funci\u00f3n print ( \"Hola, \" + nombre + \". \u00a1Bienvenido!\" ) Se escribe la palabra reservada def seguida del nombre de la funci\u00f3n y sus par\u00e1metros entre par\u00e9ntesis. Para llamar a una funci\u00f3n solo hay que escribir el nombre de la funci\u00f3n seguida de los par\u00e1metros (si los hubiera) entre par\u00e9ntesis. >>> saludo ( 'Maitane' ) Hola , Maitane . \u00a1 Bienvenida ! Es posible asignar al par\u00e1metro un valor por defecto . def saludo ( nombre = \"An\u00f3nimo\" ): print ( \"Hola, \" + nombre + \". \u00a1Bienvenido!\" ) saludo ( \"Leire\" ) # Hola, Maitane. \u00a1Bienvenida! saludo () # Hola, An\u00f3nimo. \u00a1Bienvenida! Existen dos tipos de par\u00e1metros o argumentos: Par\u00e1metros posicionales : la posici\u00f3n en la que se pasan importa Par\u00e1metros con palabra clave (keyword arguments) : la posici\u00f3n no importa, se indica una clave para cada par\u00e1metro. def suma ( a , b ): resultado = a + b print ( resultado ) suma ( 45 , 20 ) # par\u00e1metros posicionales suma ( b = 20 , a = 45 ) # parametros mediante clave Las funciones pueden devolver un valor utilizando la palabra return . Una vez devuelto un valor, la funci\u00f3n finaliza su ejecuci\u00f3n. def suma ( a , b ): resultado = a + b return resultado print ( suma ( 4 , 5 )) # 9","title":"Definir y llamar a una funci\u00f3n"},{"location":"funciones/#funciones-con-argumentos-multiples","text":"Es posible recibir un n\u00famero desconocido de par\u00e1metros a\u00f1adiendo un * en la definici\u00f3n de la funci\u00f3n. def suma_todo ( * args ): resultado = 0 for i in args : resultado += i return resultado v , w , x , y , z = 5 , 2 , 12 , 6 , 9 total = suma_todo ( v , w , x , y , z ) print ( \"La suma total es:\" + str ( total )) # La suma total es: 34","title":"Funciones con argumentos m\u00faltiples"},{"location":"funciones/#ambito-de-las-variables-scope","text":"El \u00e1mbito de una variable ( scope ) se refiere a la zona del programa d\u00f3nde una variable \"existe\". Fuera del \u00e1mbito de una variable no podremos acceder a su valor ni manejarla. Los par\u00e1metros y variables definidos en una funci\u00f3n no estar\u00e1n accesibles fuera de la funci\u00f3n. A este \u00e1mbito se le conoce como \u00e1mbito local . Es importante mencionar que una vez ejecutada una funci\u00f3n, el valor de las variables locales no se almacena, por lo que la pr\u00f3xima vez que se llame a la funci\u00f3n, \u00e9sta no recordar\u00e1 ning\u00fan valor de llamadas anteriores. def calcula (): a = 1 print ( \"Dentro de la funci\u00f3n:\" , a ) a = 5 calcula () print ( \"Fuera de la funci\u00f3n:\" , a ) ### Output ### # Dentro de la funci\u00f3n:1 # Fuera de la funci\u00f3n:5 Por el contrario, las variables definidas fuera de una funci\u00f3n s\u00ed que est\u00e1n accesibles desde dentro de la funci\u00f3n. Se considera que est\u00e1n en el \u00e1mbito global . No obstante, no se podr\u00e1n modificar dentro de la funci\u00f3n a no ser que est\u00e9n definidas con la palabra clave global .","title":"\u00c1mbito de las variables (scope)"},{"location":"funciones/#funciones-internas","text":"Python proporciona un n\u00famero importante de funciones denominadas built-in o internas, que pueden ser usadas sin necesidad de tener que definirlas previamente. Los creadores de Python han escrito este conjunto de funciones para resolver problemas comunes y las han incluido en Python para que las podamos utilizar. Un ejemplo son las funciones max y min nos dar\u00e1n respectivamente el valor mayor y menor de una lista. Dependiendo de la versi\u00f3n de Python utilizada, la lista podr\u00e1 diferir. Para Python 3.10.6 estas funciones son: Y el funcionamiento de cada una de ellas puede consultarse aqu\u00ed .","title":"Funciones internas"},{"location":"funciones/#por-que-necesitamos-las-funciones","text":"Puede no estar muy claro por qu\u00e9 merece la pena molestarse en dividir un programa en funciones. Existen varias razones: El crear una funci\u00f3n nueva te da la oportunidad de dar nombre a un grupo de sentencias, lo cual hace tu programa m\u00e1s f\u00e1cil de leer, entender y depurar. Las funciones pueden hacer un programa m\u00e1s peque\u00f1o, al eliminar c\u00f3digo repetido. Adem\u00e1s, si quieres realizar cualquier cambio en el futuro, s\u00f3lo tendr\u00e1s que hacerlo en un \u00fanico lugar. Dividir un programa largo en funciones te permite depurar las partes de una en una y luego ensamblarlas juntas en una sola pieza. Las funciones bien dise\u00f1adas a menudo resultan \u00fatiles para otros muchos programas. Una vez que has escrito y depurado una, puedes reutilizarla. Parte de la habilidad de crear y usar funciones consiste en llegar a tener una funci\u00f3n que represente correctamente una idea, como \u201cencontrar el valor m\u00e1s peque\u00f1o en una lista de valores\u201d, por ejemplo.","title":"\u00bfPor qu\u00e9 necesitamos las funciones?"},{"location":"funciones/#coding-time","text":"","title":"Coding time!"},{"location":"funciones/#ejercicio-1","text":"Crea un programa que determine si un n\u00famero es primo o no. Deber\u00e1s crear la funci\u00f3n esPrimo() que reciba como par\u00e1metro un n\u00famero y devuelva True o False indicando si el n\u00famero es primo o no.","title":"Ejercicio 1"},{"location":"funciones/#ejercicio-2","text":"Crea un programa que genere un n\u00famero aleatorio del 1 al 10. El usuario tendr\u00e1 que adivinarlo, y el programa tras cada intento le indicar\u00e1 al usuario si el n\u00famero es m\u00e1s alto, bajo o si ha acertado. La l\u00f3gica para dar la respuesta al usuario deber\u00e1 estar incluida en una funci\u00f3n a la que se llamar\u00e1 tras cada intento. Nota: Para la creaci\u00f3n del n\u00famero aleatorio, utiliza el siguiente c\u00f3digo: from random import randint , uniform , random numero = randint ( 0 , 10 )","title":"Ejercicio 2"},{"location":"funciones/#ejercicio-3","text":"Crea un programa que reciba un n\u00famero del 1 al 20 introducido por el usuario y compruebe si est\u00e1 dentro de la siguiente lista: [6,14,11,3,2,1,15,19] . Implementa una funci\u00f3n que se asegure que el n\u00famero introducido por el usuario est\u00e1 en el rango indicado y otra que compruebe si est\u00e1 dentro de la lista. Trata de crear las funciones de forma que puedan ser reutilizadas lo m\u00e1ximo posible en otros programas.","title":"Ejercicio 3"},{"location":"intro/","text":"\u00bfPor qu\u00e9 Python? En t\u00e9rminos generales, Python tiene una serie de beneficios que conviene destacar y que lo han convertido casi en est\u00e1ndar de facto en distintos campos como la ciberseguridad, por ejemplo. Algunos de estos beneficios son: Python es f\u00e1cil de aprender e implementar Python fue dise\u00f1ado intencionadamente para ser un lenguaje de programaci\u00f3n sencillo, f\u00e1cil y, en general, ligero, que requiriera un c\u00f3digo m\u00ednimo para realizar las tareas en comparaci\u00f3n con otros lenguajes. El hecho es que Python a menudo requiere mucho menos c\u00f3digo que el que se requerir\u00eda de otros lenguajes de programaci\u00f3n, como C o Java. La naturaleza de Python da lugar a una curva de aprendizaje m\u00e1s corta para cualquiera que trabaje con el lenguaje, especialmente para aquellos que son nuevos en la programaci\u00f3n. Python facilita el debugging o depuraci\u00f3n Ya hemos hablado del hecho de que la estructura de Python hace que sea m\u00e1s f\u00e1cil de aprender e implementar, pero esa naturaleza b\u00e1sica tambi\u00e9n tiene otros beneficios. El dise\u00f1o directo de Python y su facilidad de uso tambi\u00e9n aumentan su legibilidad. El aumento de la legibilidad tambi\u00e9n hace que la depuraci\u00f3n del c\u00f3digo sea mucho m\u00e1s sencilla, lo que significa que incluso los programadores de bajo nivel o principiantes pueden solucionar problemas y depurar su propio c\u00f3digo con bastante eficacia y que la correcci\u00f3n de errores puede llevernos mucho menos tiempo en general. Es open source Python fue desarrollado como un lenguaje de programaci\u00f3n de c\u00f3digo abierto, de forma similar a Linux. La naturaleza de c\u00f3digo abierto de Python se presta a una fuerte comunidad de desarrolladores que apoyan el lenguaje y lo hacen avanzar. Dado que Python es de c\u00f3digo abierto, hay una gran cantidad de informaci\u00f3n disponible, y el uso del lenguaje es gratuito. Manejo autom\u00e1tico de la memoria Otro beneficio de Python que algunas personas no tienen en cuenta es que tiene la gesti\u00f3n de la memoria incorporada autom\u00e1ticamente por dise\u00f1o. La gesti\u00f3n de memoria de Python se realiza internamente mediante su propio gestor. Esto significa que el programador y el usuario deben preocuparse menos por la gesti\u00f3n de la memoria, incluyendo factores como el almacenamiento en cach\u00e9, la asignaci\u00f3n de memoria y la segmentaci\u00f3n. \u00bfPor qu\u00e9 Python en ciberseguridad? Ya hemos hablado de las ventajas del lenguaje de programaci\u00f3n Python, y de que se utiliza en muchos campos. Ahora vamos a profundizar en por qu\u00e9 Python es tan \u00fatil para el campo de la ciberseguridad. Aut\u00e9ntico hacker de \u00e9lite megamacropro siendo muy chungo en Python Es un lenguaje interpretado Esto quiere decir que no necesita ser compilado para cada arquitectura concreta, por lo que es mucho m\u00e1s f\u00e1cil desarrollar scripts, pruebas de concepto o malware casi universal. Adem\u00e1s, esto unido a que Python viene instalado por defecto en un gran n\u00famero de distribuciones Linux, lo hacen muy atractivo tanto desde el punto de vista del atacante como del defenseor. Python se puede utilizar para pr\u00e1cticamente todo en ciberseguridad Cualquier profesional de la ciberseguridad que sea un experto en Python, podr\u00e1 llevar a cabo casi cualquier tarea que se proponga. Por ejemplo, Python puede utilizarse para crear payloads, para el an\u00e1lisis de malware, para la decodificaci\u00f3n de paquetes, para el acceso a servidores, para el escaneo de redes o para el escaneo de puertos, entre otras cosas. Python en ciberseguridad puede utilizarse tambi\u00e9n para la automatizaci\u00f3n, lo que hace que la fase de reconocimiento o recopilaci\u00f3n de informaci\u00f3n de un pentesting sea mucho m\u00e1s f\u00e1cil y ahorre tiempo. Hay que pensar que en ciberseguridad, m\u00e1s que programas completos , se suelen desarrollar scripts r\u00e1pidos y funcionales. La amplia variedad de librer\u00edas de Python Como hemos descrito anteriormente, la facilidad de uso de Python es sin duda uno de los factores m\u00e1s importantes que lo convierten en un lenguaje de referencia para los profesionales de la ciberseguridad. Pero ciertamente, la extensa biblioteca de m\u00f3dulos de Python es un factor principal tambi\u00e9n. Python se ha convertido en un lenguaje muy conocido y utilizado, debido a su extensa biblioteca, lo que significa que los profesionales de la ciberseguridad no necesitan reinventar la rueda con tareas comunes y en la mayor\u00eda de los casos pueden encontrar r\u00e1pidamente una herramienta de an\u00e1lisis de ciberseguridad o de pruebas de pentesting ya disponible. Python se puede usar para casi todo en ciberseguridad Con un buen conocimiento de Python y de los conceptos de programaci\u00f3n en general, los profesionales de la ciberseguridad pueden realizar casi cualquier tarea que necesiten utilizando c\u00f3digo Python. Por ejemplo, Python se utiliza mucho en el an\u00e1lisis de malware, el descubrimiento de hosts, el env\u00edo y la decodificaci\u00f3n de paquetes, el acceso a servidores, el escaneo de puertos y el escaneo de redes, por nombrar s\u00f3lo algunos. Teniendo en cuenta tambi\u00e9n que es tan eficaz en la creaci\u00f3n de scripts, la automatizaci\u00f3n de tareas y el an\u00e1lisis de datos, es comprensible que Python haya aumentado su popularidad a medida que la ciberseguridad se ha vuelto m\u00e1s importante. Los scripts en Python son muy r\u00e1pidos de desarrollar Otro beneficio de Python que ayuda a los profesionales de la ciberseguridad es que la facilidad del c\u00f3digo significa que los ciberprofesionales pueden desarrollar las soluciones que necesitan con una cantidad m\u00ednima de tiempo, y con un c\u00f3digo bastante simplista. Esto significa que, por ejemplo, desarrollar un script a modo de exploit como prueba de concepto para demostrar una vulnerabilidad detectada, puede llevar relativamente poco tiempo. Y para finalizar, una buena y completa respuesta que he encontrado en Quora, lo describe perfectamente: Why is Python preferred by most of the cybersecurity personnels? \u00bfPython2 o Python3? Python fue lanzado por primera vez en 1991 por el programador holand\u00e9s Guido van Rossum. Desde entonces, ha sufrido muchos cambios. Hoy en d\u00eda, hay tres versiones principales de Python. De ellas, s\u00f3lo las dos \u00faltimas versiones -Python 2 y Python 3- siguen en uso. Esto puede resultar confuso para los nuevos desarrolladores. \u00bfQu\u00e9 se deber\u00eda aprender, Python 2 o Python 3? Generalmente, la respuesta es la segunda, pero hay muchos casos en los que ayuda conocer la primera. Exploraremos la historia y el desarrollo del lenguaje, las diferencias entre Python 2 y Python 3, y los casos de uso de cada uno en los p\u00e1rrafos siguientes. Historia de Python2 vs Python3 Python 2 apareci\u00f3 en el a\u00f1o 2000. La actualizaci\u00f3n del lenguaje se dise\u00f1\u00f3 para facilitar el aprendizaje de la persona promedio, pero tambi\u00e9n agreg\u00f3 muchas caracter\u00edsticas que los desarrolladores necesitaban, como la comprensi\u00f3n de listas , el soporte de Unicode, la recolecci\u00f3n de basura y el soporte mejorado para la programaci\u00f3n orientada a objetos. Con todas estas ventajas, no fue dif\u00edcil para los desarrolladores actualizar su c\u00f3digo de Python 1 a Python 2. Python 3 sali\u00f3 en 2008 despu\u00e9s de que van Rossum encontrara nuevas formas de mejorar el lenguaje. En la programaci\u00f3n se aprende sobre la marcha, y a veces los problemas s\u00f3lo aparecen al final del proceso. Pero estas mejoras s\u00f3lo pod\u00edan hacerse con una nueva versi\u00f3n de Python que no fuera compatible con Python 2. La falta de retrocompatibilidad de Python 3 era un problema para muchos desarrolladores, ya que depend\u00edan de las bibliotecas de terceros escritas para soportar Python 2 para agilizar el desarrollo de sus aplicaciones. Dada la popularidad de Python y sus bibliotecas asociadas, el c\u00f3digo de Python 2 estaba por todas partes, y era dif\u00edcil conseguir que la gente hiciera el cambio. La \u00faltima versi\u00f3n de Python 2 se public\u00f3 en 2010, despu\u00e9s del lanzamiento inicial de Python 3. Inicialmente, se supon\u00eda que el soporte para Python 2 terminar\u00eda en 2015, pero debido a que segu\u00eda siendo tan ampliamente utilizado, la fecha l\u00edmite se retras\u00f3 hasta enero de 2020. Resumiendo Se debe aprender o seguir desarrollando en Python3 ya que Python2 est\u00e1 obsoleto y fuera de soporte. No obstante, mucho c\u00f3digo legacy, librer\u00edas de terceros y, en nuestro caso, muchos exploits y pruebas de concepto siguen estando escritos en Python2, por lo que es necesario, al menos, conocerlo. Diferencias entre Python2 y Python3 Las diferencias pueden ser sustanciales en algunos casos. Dado que no es el objetivo de este curso, os dejo aqu\u00ed un sitio web donde se explican de una forma m\u00e1s o menos detalladas. Esta imagen lo muestra de una form aresumida: Otros recursos, en ingl\u00e9s, para consultar las diferencias de forma detallada son este y este . Instalaci\u00f3n de Python Como era de esperar, es imprescindible tener instalado en nuestro sistema Python para poder utilizar Python, sorpresas nos da la vida. Dicho esto, veamos c\u00f3mo hacerlo. Python3 En este curso yo trabajar\u00e9 \u00edntegramente con Python3 en Linux, lo cual no es \u00f3bice para que vosotros pod\u00e1is usarlo en Windows, OSX o WSL si as\u00ed lo dese\u00e1is. Una idea es utilizar una m\u00e1quina virtual Linux o un contenedor Docker pero, de nuevo, s\u00f3is libres de elegir. En la misma medida, el IDE que utilizar\u00e9 ser\u00e1 Visual Studio Code en Linux. Vosotros s\u00f3is libres de utilizar \u00e9ste en Windows, Linux, OSX o cualquier otro IDE(como Anaconda por ejemplo) en cualquier sistema. La instalaci\u00f3n en Windows es igual de sencilla que cualquier otro software y pod\u00e9is realizarsa siguiendo tutoriales como este , este o este Para Linux y MacOSX en el \u00faltimo tutorial de los anteriores hay unas secciones dedicadas a ellos. Para Linux Debian o similares como Ubuntu y Mint, pod\u00e9is seguir los pasos que se indican aqu\u00ed o aqu\u00ed . Para cualquier Linux que no sea Debian , probablemente no sea necesario daros instrucciones sobre c\u00f3mo encontrar la forma de instalarlo. Ambientes virtuales y pipenv Entornos virtuales en Python Un entorno virtual es una forma de tener m\u00faltiples instancias paralelas del int\u00e9rprete de Python, cada una con diferentes conjuntos de paquetes y diferentes configuraciones. Cada entorno virtual contiene una copia independiente del int\u00e9rprete de Python, incluyendo copias de sus utilidades de soporte. Los paquetes instalados en cada entorno virtual s\u00f3lo se ven en ese entorno virtual y en ning\u00fan otro. Incluso los paquetes grandes y complejos con binarios dependientes de la plataforma pueden ser aislados entre s\u00ed en entornos virtuales. De esta forma, tendremos entornos independientes entre s\u00ed, parecido a como ocurre con los directorios de los proyectos de Node.js y npm . De este modo, los entornos virtuales de Python nos permiten instalar un paquete de Python en una ubicaci\u00f3n aislada en lugar de instalarlo de manera global. Pipenv Pipenv es una herramienta que apunta a traer todo lo mejor del mundo de empaquetado (bundler, composer, npm, cargo, yarn, etc.) al mundo de Python. Autom\u00e1ticamente crea y maneja un entorno virtual para tus proyectos, tambi\u00e9n permite agregar/eliminar paquetes desde tu Pipfile as\u00ed como como instalar/desinstalar paquetes. Tambi\u00e9n genera lo m\u00e1s importante , el archivo Pipfile.lock , que es usado para producir determinado build. Instalar pipenv En Linux: Instalamos el gestor de paquetes de Python pip: sudo apt-get update sudo apt-get install python3-pip Instalamos el paquete pipenv para gestionar los entornos virtuales: pip3 install pipenv Y comprobamos que est\u00e1 instalado correctamente mostrando su versi\u00f3n: pipenv --version En Windows: Instalamos pip mediante el script get-pip.py siguiendo el procedimiento que se nos indica aqu\u00ed o aqu\u00ed Ejecutar: pip install pipenv Referencias 5 Big Reasons Python is Useful in Cybersecurity Beginners Guide on Python for Cybersecurity Python 2 vs. Python 3: Which should you learn? Pipenv: gestor de entornos virtuales de Python Configure a Pipenv environment","title":"Introducci\u00f3n"},{"location":"intro/#por-que-python","text":"En t\u00e9rminos generales, Python tiene una serie de beneficios que conviene destacar y que lo han convertido casi en est\u00e1ndar de facto en distintos campos como la ciberseguridad, por ejemplo. Algunos de estos beneficios son:","title":"\u00bfPor qu\u00e9 Python?"},{"location":"intro/#python-es-facil-de-aprender-e-implementar","text":"Python fue dise\u00f1ado intencionadamente para ser un lenguaje de programaci\u00f3n sencillo, f\u00e1cil y, en general, ligero, que requiriera un c\u00f3digo m\u00ednimo para realizar las tareas en comparaci\u00f3n con otros lenguajes. El hecho es que Python a menudo requiere mucho menos c\u00f3digo que el que se requerir\u00eda de otros lenguajes de programaci\u00f3n, como C o Java. La naturaleza de Python da lugar a una curva de aprendizaje m\u00e1s corta para cualquiera que trabaje con el lenguaje, especialmente para aquellos que son nuevos en la programaci\u00f3n.","title":"Python es f\u00e1cil de aprender e implementar"},{"location":"intro/#python-facilita-el-debugging-o-depuracion","text":"Ya hemos hablado del hecho de que la estructura de Python hace que sea m\u00e1s f\u00e1cil de aprender e implementar, pero esa naturaleza b\u00e1sica tambi\u00e9n tiene otros beneficios. El dise\u00f1o directo de Python y su facilidad de uso tambi\u00e9n aumentan su legibilidad. El aumento de la legibilidad tambi\u00e9n hace que la depuraci\u00f3n del c\u00f3digo sea mucho m\u00e1s sencilla, lo que significa que incluso los programadores de bajo nivel o principiantes pueden solucionar problemas y depurar su propio c\u00f3digo con bastante eficacia y que la correcci\u00f3n de errores puede llevernos mucho menos tiempo en general.","title":"Python facilita el debugging o depuraci\u00f3n"},{"location":"intro/#es-open-source","text":"Python fue desarrollado como un lenguaje de programaci\u00f3n de c\u00f3digo abierto, de forma similar a Linux. La naturaleza de c\u00f3digo abierto de Python se presta a una fuerte comunidad de desarrolladores que apoyan el lenguaje y lo hacen avanzar. Dado que Python es de c\u00f3digo abierto, hay una gran cantidad de informaci\u00f3n disponible, y el uso del lenguaje es gratuito.","title":"Es open source"},{"location":"intro/#manejo-automatico-de-la-memoria","text":"Otro beneficio de Python que algunas personas no tienen en cuenta es que tiene la gesti\u00f3n de la memoria incorporada autom\u00e1ticamente por dise\u00f1o. La gesti\u00f3n de memoria de Python se realiza internamente mediante su propio gestor. Esto significa que el programador y el usuario deben preocuparse menos por la gesti\u00f3n de la memoria, incluyendo factores como el almacenamiento en cach\u00e9, la asignaci\u00f3n de memoria y la segmentaci\u00f3n.","title":"Manejo autom\u00e1tico de la memoria"},{"location":"intro/#por-que-python-en-ciberseguridad","text":"Ya hemos hablado de las ventajas del lenguaje de programaci\u00f3n Python, y de que se utiliza en muchos campos. Ahora vamos a profundizar en por qu\u00e9 Python es tan \u00fatil para el campo de la ciberseguridad. Aut\u00e9ntico hacker de \u00e9lite megamacropro siendo muy chungo en Python","title":"\u00bfPor qu\u00e9 Python en ciberseguridad?"},{"location":"intro/#es-un-lenguaje-interpretado","text":"Esto quiere decir que no necesita ser compilado para cada arquitectura concreta, por lo que es mucho m\u00e1s f\u00e1cil desarrollar scripts, pruebas de concepto o malware casi universal. Adem\u00e1s, esto unido a que Python viene instalado por defecto en un gran n\u00famero de distribuciones Linux, lo hacen muy atractivo tanto desde el punto de vista del atacante como del defenseor.","title":"Es un lenguaje interpretado"},{"location":"intro/#python-se-puede-utilizar-para-practicamente-todo-en-ciberseguridad","text":"Cualquier profesional de la ciberseguridad que sea un experto en Python, podr\u00e1 llevar a cabo casi cualquier tarea que se proponga. Por ejemplo, Python puede utilizarse para crear payloads, para el an\u00e1lisis de malware, para la decodificaci\u00f3n de paquetes, para el acceso a servidores, para el escaneo de redes o para el escaneo de puertos, entre otras cosas. Python en ciberseguridad puede utilizarse tambi\u00e9n para la automatizaci\u00f3n, lo que hace que la fase de reconocimiento o recopilaci\u00f3n de informaci\u00f3n de un pentesting sea mucho m\u00e1s f\u00e1cil y ahorre tiempo. Hay que pensar que en ciberseguridad, m\u00e1s que programas completos , se suelen desarrollar scripts r\u00e1pidos y funcionales.","title":"Python se puede utilizar para pr\u00e1cticamente todo en ciberseguridad"},{"location":"intro/#la-amplia-variedad-de-librerias-de-python","text":"Como hemos descrito anteriormente, la facilidad de uso de Python es sin duda uno de los factores m\u00e1s importantes que lo convierten en un lenguaje de referencia para los profesionales de la ciberseguridad. Pero ciertamente, la extensa biblioteca de m\u00f3dulos de Python es un factor principal tambi\u00e9n. Python se ha convertido en un lenguaje muy conocido y utilizado, debido a su extensa biblioteca, lo que significa que los profesionales de la ciberseguridad no necesitan reinventar la rueda con tareas comunes y en la mayor\u00eda de los casos pueden encontrar r\u00e1pidamente una herramienta de an\u00e1lisis de ciberseguridad o de pruebas de pentesting ya disponible.","title":"La amplia variedad de librer\u00edas de Python"},{"location":"intro/#python-se-puede-usar-para-casi-todo-en-ciberseguridad","text":"Con un buen conocimiento de Python y de los conceptos de programaci\u00f3n en general, los profesionales de la ciberseguridad pueden realizar casi cualquier tarea que necesiten utilizando c\u00f3digo Python. Por ejemplo, Python se utiliza mucho en el an\u00e1lisis de malware, el descubrimiento de hosts, el env\u00edo y la decodificaci\u00f3n de paquetes, el acceso a servidores, el escaneo de puertos y el escaneo de redes, por nombrar s\u00f3lo algunos. Teniendo en cuenta tambi\u00e9n que es tan eficaz en la creaci\u00f3n de scripts, la automatizaci\u00f3n de tareas y el an\u00e1lisis de datos, es comprensible que Python haya aumentado su popularidad a medida que la ciberseguridad se ha vuelto m\u00e1s importante.","title":"Python se puede usar para casi todo en ciberseguridad"},{"location":"intro/#los-scripts-en-python-son-muy-rapidos-de-desarrollar","text":"Otro beneficio de Python que ayuda a los profesionales de la ciberseguridad es que la facilidad del c\u00f3digo significa que los ciberprofesionales pueden desarrollar las soluciones que necesitan con una cantidad m\u00ednima de tiempo, y con un c\u00f3digo bastante simplista. Esto significa que, por ejemplo, desarrollar un script a modo de exploit como prueba de concepto para demostrar una vulnerabilidad detectada, puede llevar relativamente poco tiempo. Y para finalizar, una buena y completa respuesta que he encontrado en Quora, lo describe perfectamente: Why is Python preferred by most of the cybersecurity personnels?","title":"Los scripts en Python son muy r\u00e1pidos de desarrollar"},{"location":"intro/#python2-o-python3","text":"Python fue lanzado por primera vez en 1991 por el programador holand\u00e9s Guido van Rossum. Desde entonces, ha sufrido muchos cambios. Hoy en d\u00eda, hay tres versiones principales de Python. De ellas, s\u00f3lo las dos \u00faltimas versiones -Python 2 y Python 3- siguen en uso. Esto puede resultar confuso para los nuevos desarrolladores. \u00bfQu\u00e9 se deber\u00eda aprender, Python 2 o Python 3? Generalmente, la respuesta es la segunda, pero hay muchos casos en los que ayuda conocer la primera. Exploraremos la historia y el desarrollo del lenguaje, las diferencias entre Python 2 y Python 3, y los casos de uso de cada uno en los p\u00e1rrafos siguientes.","title":"\u00bfPython2 o Python3?"},{"location":"intro/#historia-de-python2-vs-python3","text":"Python 2 apareci\u00f3 en el a\u00f1o 2000. La actualizaci\u00f3n del lenguaje se dise\u00f1\u00f3 para facilitar el aprendizaje de la persona promedio, pero tambi\u00e9n agreg\u00f3 muchas caracter\u00edsticas que los desarrolladores necesitaban, como la comprensi\u00f3n de listas , el soporte de Unicode, la recolecci\u00f3n de basura y el soporte mejorado para la programaci\u00f3n orientada a objetos. Con todas estas ventajas, no fue dif\u00edcil para los desarrolladores actualizar su c\u00f3digo de Python 1 a Python 2. Python 3 sali\u00f3 en 2008 despu\u00e9s de que van Rossum encontrara nuevas formas de mejorar el lenguaje. En la programaci\u00f3n se aprende sobre la marcha, y a veces los problemas s\u00f3lo aparecen al final del proceso. Pero estas mejoras s\u00f3lo pod\u00edan hacerse con una nueva versi\u00f3n de Python que no fuera compatible con Python 2. La falta de retrocompatibilidad de Python 3 era un problema para muchos desarrolladores, ya que depend\u00edan de las bibliotecas de terceros escritas para soportar Python 2 para agilizar el desarrollo de sus aplicaciones. Dada la popularidad de Python y sus bibliotecas asociadas, el c\u00f3digo de Python 2 estaba por todas partes, y era dif\u00edcil conseguir que la gente hiciera el cambio. La \u00faltima versi\u00f3n de Python 2 se public\u00f3 en 2010, despu\u00e9s del lanzamiento inicial de Python 3. Inicialmente, se supon\u00eda que el soporte para Python 2 terminar\u00eda en 2015, pero debido a que segu\u00eda siendo tan ampliamente utilizado, la fecha l\u00edmite se retras\u00f3 hasta enero de 2020. Resumiendo Se debe aprender o seguir desarrollando en Python3 ya que Python2 est\u00e1 obsoleto y fuera de soporte. No obstante, mucho c\u00f3digo legacy, librer\u00edas de terceros y, en nuestro caso, muchos exploits y pruebas de concepto siguen estando escritos en Python2, por lo que es necesario, al menos, conocerlo.","title":"Historia de Python2 vs Python3"},{"location":"intro/#diferencias-entre-python2-y-python3","text":"Las diferencias pueden ser sustanciales en algunos casos. Dado que no es el objetivo de este curso, os dejo aqu\u00ed un sitio web donde se explican de una forma m\u00e1s o menos detalladas. Esta imagen lo muestra de una form aresumida: Otros recursos, en ingl\u00e9s, para consultar las diferencias de forma detallada son este y este .","title":"Diferencias entre Python2 y Python3"},{"location":"intro/#instalacion-de-python","text":"Como era de esperar, es imprescindible tener instalado en nuestro sistema Python para poder utilizar Python, sorpresas nos da la vida. Dicho esto, veamos c\u00f3mo hacerlo.","title":"Instalaci\u00f3n de Python"},{"location":"intro/#python3","text":"En este curso yo trabajar\u00e9 \u00edntegramente con Python3 en Linux, lo cual no es \u00f3bice para que vosotros pod\u00e1is usarlo en Windows, OSX o WSL si as\u00ed lo dese\u00e1is. Una idea es utilizar una m\u00e1quina virtual Linux o un contenedor Docker pero, de nuevo, s\u00f3is libres de elegir. En la misma medida, el IDE que utilizar\u00e9 ser\u00e1 Visual Studio Code en Linux. Vosotros s\u00f3is libres de utilizar \u00e9ste en Windows, Linux, OSX o cualquier otro IDE(como Anaconda por ejemplo) en cualquier sistema. La instalaci\u00f3n en Windows es igual de sencilla que cualquier otro software y pod\u00e9is realizarsa siguiendo tutoriales como este , este o este Para Linux y MacOSX en el \u00faltimo tutorial de los anteriores hay unas secciones dedicadas a ellos. Para Linux Debian o similares como Ubuntu y Mint, pod\u00e9is seguir los pasos que se indican aqu\u00ed o aqu\u00ed . Para cualquier Linux que no sea Debian , probablemente no sea necesario daros instrucciones sobre c\u00f3mo encontrar la forma de instalarlo.","title":"Python3"},{"location":"intro/#ambientes-virtuales-y-pipenv","text":"","title":"Ambientes virtuales y pipenv"},{"location":"intro/#entornos-virtuales-en-python","text":"Un entorno virtual es una forma de tener m\u00faltiples instancias paralelas del int\u00e9rprete de Python, cada una con diferentes conjuntos de paquetes y diferentes configuraciones. Cada entorno virtual contiene una copia independiente del int\u00e9rprete de Python, incluyendo copias de sus utilidades de soporte. Los paquetes instalados en cada entorno virtual s\u00f3lo se ven en ese entorno virtual y en ning\u00fan otro. Incluso los paquetes grandes y complejos con binarios dependientes de la plataforma pueden ser aislados entre s\u00ed en entornos virtuales. De esta forma, tendremos entornos independientes entre s\u00ed, parecido a como ocurre con los directorios de los proyectos de Node.js y npm . De este modo, los entornos virtuales de Python nos permiten instalar un paquete de Python en una ubicaci\u00f3n aislada en lugar de instalarlo de manera global.","title":"Entornos virtuales en Python"},{"location":"intro/#pipenv","text":"Pipenv es una herramienta que apunta a traer todo lo mejor del mundo de empaquetado (bundler, composer, npm, cargo, yarn, etc.) al mundo de Python. Autom\u00e1ticamente crea y maneja un entorno virtual para tus proyectos, tambi\u00e9n permite agregar/eliminar paquetes desde tu Pipfile as\u00ed como como instalar/desinstalar paquetes. Tambi\u00e9n genera lo m\u00e1s importante , el archivo Pipfile.lock , que es usado para producir determinado build.","title":"Pipenv"},{"location":"intro/#instalar-pipenv","text":"En Linux: Instalamos el gestor de paquetes de Python pip: sudo apt-get update sudo apt-get install python3-pip Instalamos el paquete pipenv para gestionar los entornos virtuales: pip3 install pipenv Y comprobamos que est\u00e1 instalado correctamente mostrando su versi\u00f3n: pipenv --version En Windows: Instalamos pip mediante el script get-pip.py siguiendo el procedimiento que se nos indica aqu\u00ed o aqu\u00ed Ejecutar: pip install pipenv","title":"Instalar pipenv"},{"location":"intro/#referencias","text":"5 Big Reasons Python is Useful in Cybersecurity Beginners Guide on Python for Cybersecurity Python 2 vs. Python 3: Which should you learn? Pipenv: gestor de entornos virtuales de Python Configure a Pipenv environment","title":"Referencias"},{"location":"iteradores/","text":"","title":"Iteradores"},{"location":"keylogger/","text":"Este ejercicio consistir\u00e1 en programar un tipo de keylogger para Linux. Se ofrecen dos v\u00edas para implementar este ejercicio, una sencilla y otra una versi\u00f3n mejorada para los m\u00e1s avezados. Consejo Os recomiendo crear un nuevo entorno virtual con pipenv y sobre \u00e9l instalar los paquetes que sean necesarios. Versi\u00f3n sencilla Esta versi\u00f3n lo \u00fanico que har\u00e1 ser\u00e1 mostrar por pantalla continuamente una lista con lo que contiene nuestro portapapeles, a\u00f1adiendo un nuevo elemento a esta lista cada vez que se copia algo a dicho portapapeles ( CTRL+C ). Vamos a utilizar una biblioteca concreta, que deber\u00e9is instalar y sobre la que deb\u00e9is informaros a prop\u00f3sito de su sencillo funcionamiento: Pyperclip Los pasos a seguir ser\u00e1n: Importar ambas bibliotecas Crear una lista vac\u00eda, que ser\u00e1 la que contendr\u00e1 el contenido del portapapeles Tras ello, deb\u00e9is crear un bucle infinito: Si el contenido del portapapeles no est\u00e1 vac\u00edo ( '' ) debemos guardar su valor en una variable Para asegurarnos de no guardar valores repetidos, si el valor del punto anterior no est\u00e1 en la lista, a\u00f1adimos el valor al final de la lista Imprimimos la lista por pantall Una mejora muy sencilla de este ejercicio ser\u00eda guardar el resultado en un archivo .txt . Versi\u00f3n mejorada","title":"Programamos un keylogger"},{"location":"keylogger/#version-sencilla","text":"Esta versi\u00f3n lo \u00fanico que har\u00e1 ser\u00e1 mostrar por pantalla continuamente una lista con lo que contiene nuestro portapapeles, a\u00f1adiendo un nuevo elemento a esta lista cada vez que se copia algo a dicho portapapeles ( CTRL+C ). Vamos a utilizar una biblioteca concreta, que deber\u00e9is instalar y sobre la que deb\u00e9is informaros a prop\u00f3sito de su sencillo funcionamiento: Pyperclip Los pasos a seguir ser\u00e1n: Importar ambas bibliotecas Crear una lista vac\u00eda, que ser\u00e1 la que contendr\u00e1 el contenido del portapapeles Tras ello, deb\u00e9is crear un bucle infinito: Si el contenido del portapapeles no est\u00e1 vac\u00edo ( '' ) debemos guardar su valor en una variable Para asegurarnos de no guardar valores repetidos, si el valor del punto anterior no est\u00e1 en la lista, a\u00f1adimos el valor al final de la lista Imprimimos la lista por pantall Una mejora muy sencilla de este ejercicio ser\u00eda guardar el resultado en un archivo .txt .","title":"Versi\u00f3n sencilla"},{"location":"keylogger/#version-mejorada","text":"","title":"Versi\u00f3n mejorada"},{"location":"listas/","text":"Listas y tuplas Las listas permiten guardar m\u00e1s de un elemento dentro de una variable, y adem\u00e1s hacerlo en un orden concreto. Pueden contener un n\u00famero ilimitado de elementos de cualquier tipo : # Lista vac\u00eda lista_vacia = [] # Lista con valores alumnos = [ \"Ane\" , \"Unai\" , \"Itziar\" , \"Mikel\" ] # Acceder a elementos print ( alumnos [ 0 ]) # muestra \"Ane\" print ( alumnos [ 1 ]) # muestra \"Unai\" print ( alumnos [ 2 ]) # muestra \"Itziar\" print ( alumnos [ - 1 ]) # muestra \"Mikel\" # Cambiar un elemento alumnos [ 0 ] = \"Nora\" Los m\u00e9todos m\u00e1s utilizados con las listas son los siguientes: M\u00e9todo Acci\u00f3n alumnos.append(\"Amaia\") Inserta \"Jon\" al final de la lista alumnos.insert(0,\"Amaia\") Inserta \"Amaia\" en la posici\u00f3n 0 alumnos.remove(\"Amaia\") Elimina la primera aparici\u00f3n de \"Amaia\" de la lista alumnos.pop() Elimina el \u00faltimo elemento de la lista alumnos.pop(3) Elimina el cuarto elemento de la lista alumnos.clear() Elimina todos los elementos de la lista alumnos.index(\"Amaia\") Devuelve el \u00edndice de la primera aparici\u00f3n de \"Amaia\" alumnos.sort() Ordena la lista (los elementos deben ser comparables) sorted(alumnos) Devuelve una copia de la lista 'alumnos' ordenada (no ordena la pasada como par\u00e1metro) alumnos.reverse() Ordena la lista en orden inverso alumnos.copy() Devuelve una copia de la lista alumnos.extend(otra_lista) Fusiona las dos listas Acceder a varios elementos de una lista Si queremos acceder a un subconjunto de elementos de la lista, es posible hacerlo de la siguiente manera: lista = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] # Elementos de la segunda a la cuarta posici\u00f3n print ( lista [ 1 : 3 ]) # Salida: ['b', 'c'] # Elementos desde la primera hasta la cuarta posici\u00f3n print ( lista [: 3 ]) # Salida: ['a', 'b', 'c'] # Elementos desde la tercera posici\u00f3n hasta el final print ( lista [ 2 :]) # Salida: ['c', 'd', 'e', 'f'] Recorrer una lista La forma habitual de recorrer una lista es mediante la sentencia for , tal y como muestra el ejemplo a continuaci\u00f3n: for elemento in [ 'Python' , 'JavaScript' , 'JAVA' ]: print ( \"Programo en\" , elemento ) De igual manera se podr\u00eda hacer mediante la sentencia while : lista = [ 'Python' , 'JavaScript' , 'JAVA' ] i = 0 sizeofList = len ( lista ) while i < sizeofList : print ( lista [ i ]) i += 1 Tuplas Las tuplas son listas inmutables . Es decir, una vez declaradas, no se pueden realizar modificaciones sobre ellas (a\u00f1adir/eliminar elementos o hacer modificaciones sobre ellos). Para definir una tupla se escriben los elementos entre par\u00e9ntesis: valores = ( 1 , 2 , 3 , 4 , 5 ) print ( valores ) # Salida: (1, 2, 3, 4, 5) # tuple with mixed datatypes valores_mixtos = ( 1 , \"Hola\" , 2.5 , False ) print ( valores_mixtos ) # Salida: (1, 'Hola', 2.5, False) El acceso a sus elementos se hace de igual que con listas: valores = ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" ) print ( valores [ 1 ]) # Salida: 'b' print ( valores [ 2 : 4 ]) # Salida: ('c', 'd') Una acci\u00f3n t\u00edpica de las tuplas es \"desempaquetar\" (unpack) sus valores, es decir, asignarlos a variables directamente: tupla = ( 1 , \"Hola\" , 2.5 ) # Creamos la tupla var1 , var2 , var3 = tupla # Hacemos el unpack print ( var1 ) # 1 print ( var2 ) # 'Hola' print ( var3 ) # 2.5 Coding time! Ejercicio 1 Dada la siguiente lista [12, 23, 5, 29, 92, 64] realiza las siguientes operaciones y vete mostrando la lista resultante por pantalla: Elimina el \u00faltimo n\u00famero y a\u00f1\u00e1delo al principio. Mueve el segundo elemento a la \u00faltima posici\u00f3n. A\u00f1ade el n\u00famero 14 al comienzo de la lista. Suma todos los n\u00fameros de la lista y a\u00f1ade el resultado al final de la lista. Fusiona la lista actual con la siguiente: [4, 11, 32] Elimina todos los n\u00fameros impares de la lista. Ordena los n\u00fameros de la lista de forma ascendente. Vac\u00eda la lista. Resultado: [64, 12, 23, 5, 29, 92] [64, 23, 5, 29, 92, 12] [14, 64, 23, 5, 29, 92, 12] [14, 64, 23, 5, 29, 92, 12, 239] [14, 64, 23, 5, 29, 92, 12, 239, 4, 11, 32] [14, 64, 92, 12, 4, 32] [4, 12, 14, 32, 64, 92] [] Ejercicio 2 Crea un programa que solicite al usuario 5 n\u00fameros y los guarde en una lista. A continuaci\u00f3n el programa pedir\u00e1 otros 5 n\u00fameros al usuario almacen\u00e1ndolos en una segunda lista. El programa mostrar\u00e1 al usuario una lista que contenga los n\u00fameros que tienen en com\u00fan las dos listas anteriores. Ejemplo: Lista 1 = [6,14,11,78,5] y Lista 2 = [3,14,22,78,9] Resultado: [14, 78]","title":"Listas y tuplas"},{"location":"listas/#listas-y-tuplas","text":"Las listas permiten guardar m\u00e1s de un elemento dentro de una variable, y adem\u00e1s hacerlo en un orden concreto. Pueden contener un n\u00famero ilimitado de elementos de cualquier tipo : # Lista vac\u00eda lista_vacia = [] # Lista con valores alumnos = [ \"Ane\" , \"Unai\" , \"Itziar\" , \"Mikel\" ] # Acceder a elementos print ( alumnos [ 0 ]) # muestra \"Ane\" print ( alumnos [ 1 ]) # muestra \"Unai\" print ( alumnos [ 2 ]) # muestra \"Itziar\" print ( alumnos [ - 1 ]) # muestra \"Mikel\" # Cambiar un elemento alumnos [ 0 ] = \"Nora\" Los m\u00e9todos m\u00e1s utilizados con las listas son los siguientes: M\u00e9todo Acci\u00f3n alumnos.append(\"Amaia\") Inserta \"Jon\" al final de la lista alumnos.insert(0,\"Amaia\") Inserta \"Amaia\" en la posici\u00f3n 0 alumnos.remove(\"Amaia\") Elimina la primera aparici\u00f3n de \"Amaia\" de la lista alumnos.pop() Elimina el \u00faltimo elemento de la lista alumnos.pop(3) Elimina el cuarto elemento de la lista alumnos.clear() Elimina todos los elementos de la lista alumnos.index(\"Amaia\") Devuelve el \u00edndice de la primera aparici\u00f3n de \"Amaia\" alumnos.sort() Ordena la lista (los elementos deben ser comparables) sorted(alumnos) Devuelve una copia de la lista 'alumnos' ordenada (no ordena la pasada como par\u00e1metro) alumnos.reverse() Ordena la lista en orden inverso alumnos.copy() Devuelve una copia de la lista alumnos.extend(otra_lista) Fusiona las dos listas","title":"Listas y tuplas"},{"location":"listas/#acceder-a-varios-elementos-de-una-lista","text":"Si queremos acceder a un subconjunto de elementos de la lista, es posible hacerlo de la siguiente manera: lista = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] # Elementos de la segunda a la cuarta posici\u00f3n print ( lista [ 1 : 3 ]) # Salida: ['b', 'c'] # Elementos desde la primera hasta la cuarta posici\u00f3n print ( lista [: 3 ]) # Salida: ['a', 'b', 'c'] # Elementos desde la tercera posici\u00f3n hasta el final print ( lista [ 2 :]) # Salida: ['c', 'd', 'e', 'f']","title":"Acceder a varios elementos de una lista"},{"location":"listas/#recorrer-una-lista","text":"La forma habitual de recorrer una lista es mediante la sentencia for , tal y como muestra el ejemplo a continuaci\u00f3n: for elemento in [ 'Python' , 'JavaScript' , 'JAVA' ]: print ( \"Programo en\" , elemento ) De igual manera se podr\u00eda hacer mediante la sentencia while : lista = [ 'Python' , 'JavaScript' , 'JAVA' ] i = 0 sizeofList = len ( lista ) while i < sizeofList : print ( lista [ i ]) i += 1","title":"Recorrer una lista"},{"location":"listas/#tuplas","text":"Las tuplas son listas inmutables . Es decir, una vez declaradas, no se pueden realizar modificaciones sobre ellas (a\u00f1adir/eliminar elementos o hacer modificaciones sobre ellos). Para definir una tupla se escriben los elementos entre par\u00e9ntesis: valores = ( 1 , 2 , 3 , 4 , 5 ) print ( valores ) # Salida: (1, 2, 3, 4, 5) # tuple with mixed datatypes valores_mixtos = ( 1 , \"Hola\" , 2.5 , False ) print ( valores_mixtos ) # Salida: (1, 'Hola', 2.5, False) El acceso a sus elementos se hace de igual que con listas: valores = ( \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" ) print ( valores [ 1 ]) # Salida: 'b' print ( valores [ 2 : 4 ]) # Salida: ('c', 'd') Una acci\u00f3n t\u00edpica de las tuplas es \"desempaquetar\" (unpack) sus valores, es decir, asignarlos a variables directamente: tupla = ( 1 , \"Hola\" , 2.5 ) # Creamos la tupla var1 , var2 , var3 = tupla # Hacemos el unpack print ( var1 ) # 1 print ( var2 ) # 'Hola' print ( var3 ) # 2.5","title":"Tuplas"},{"location":"listas/#coding-time","text":"","title":"Coding time!"},{"location":"listas/#ejercicio-1","text":"Dada la siguiente lista [12, 23, 5, 29, 92, 64] realiza las siguientes operaciones y vete mostrando la lista resultante por pantalla: Elimina el \u00faltimo n\u00famero y a\u00f1\u00e1delo al principio. Mueve el segundo elemento a la \u00faltima posici\u00f3n. A\u00f1ade el n\u00famero 14 al comienzo de la lista. Suma todos los n\u00fameros de la lista y a\u00f1ade el resultado al final de la lista. Fusiona la lista actual con la siguiente: [4, 11, 32] Elimina todos los n\u00fameros impares de la lista. Ordena los n\u00fameros de la lista de forma ascendente. Vac\u00eda la lista. Resultado: [64, 12, 23, 5, 29, 92] [64, 23, 5, 29, 92, 12] [14, 64, 23, 5, 29, 92, 12] [14, 64, 23, 5, 29, 92, 12, 239] [14, 64, 23, 5, 29, 92, 12, 239, 4, 11, 32] [14, 64, 92, 12, 4, 32] [4, 12, 14, 32, 64, 92] []","title":"Ejercicio 1"},{"location":"listas/#ejercicio-2","text":"Crea un programa que solicite al usuario 5 n\u00fameros y los guarde en una lista. A continuaci\u00f3n el programa pedir\u00e1 otros 5 n\u00fameros al usuario almacen\u00e1ndolos en una segunda lista. El programa mostrar\u00e1 al usuario una lista que contenga los n\u00fameros que tienen en com\u00fan las dos listas anteriores. Ejemplo: Lista 1 = [6,14,11,78,5] y Lista 2 = [3,14,22,78,9] Resultado: [14, 78]","title":"Ejercicio 2"},{"location":"mechanical/","text":"Mechanical Soup Introducci\u00f3n MechanicalSoup es un paquete de Python que, de forma autom\u00e1tica, env\u00eda cookies, sigue redirecciones y tambi\u00e9n puede seguir hiperenlaces o formularios de un sitio web. Fue creado por M. Hickford debido a su fascinaci\u00f3n por la biblioteca Mechanize. Mechanize fue un proyecto de John J. Lee que permitia navegar de forma program\u00e1tica en Python. Algunas de las caracter\u00edsticas de Mechanize eran: mechanize.browser : que usa urllib2.OpenerDirector para abrir una URL de Internet Completado f\u00e1cil de formularios HTML Revisi\u00f3n autom\u00e1tica de robots.txt Manejo autom\u00e1tica de HTTP-Equiv M\u00e9todos de navegador .back() y .reload Desafortunadamente, Mechanize no es compatible con Python3 y, adem\u00e1s, su desarrollo lleva a\u00f1os estancado. En este contexto, Hickford emergi\u00f3 con una soluci\u00f3n: MechanicalSoup que provee la misma API y que est\u00e1 construido sobre las bibliotecas Requests (para las sesiones HTTP) y BeautifulSoup (para datos de navegaci\u00f3n). MechanicalSoup est\u00e1 dise\u00f1ado para imitar el comportamiento de los humanos cuando interact\u00faan con los navegadores web. Algunos de los posibles casos de uso incluyen: Interactuar con sitios web que no proporcionan API Hacer pruebas de un sitio web que se est\u00e9 desarrollando Navegar a trav\u00e9s de una interfaz Instalaci\u00f3n y comprobaci\u00f3n Lo primero que deberemos hacer, como siempre, es instalar MechanicalSoup. Podemos hacerlo en nuestro entorno virtual: pipenv shell pipenv install mechanicalsoup O, de forma general, en nuestra m\u00e1quina: pipenv install mechanicalsoup Comprobemos que no tenemos errores con nuestra nueva biblioteca. Para ello, en el entorno interactivo de Python3: import mechanicalsoup browser = mechanicalsoup . StatefulBrowser () url = \"http://httpbin.org\" browser . open ( url ) print ( browser . get_url ()) En el c\u00f3digo de arriba: Importamos la biblioteca mechanicalsoup.StatefulBrowser() crear\u00e1 un objeto de navegador. browser.open() brir\u00e1 la p\u00e1gina deseado en segundo plano y devolver\u00e1 un response[200] que es el valor devuelto por open() . MechanicalSoup usa la biblioteca requests para realizar las peticiones HTTP a los sitios. browser.get_url() recoge la URL del sitio y tambi\u00e9n usa requests Trabajar con MechanicalSoup Siguiendo con el ejemplo anterior, podemos llevar a cabo m\u00e1s acciones, como por ejemplo seguir subdominios de la siguiente forma: browser . follow_link ( \"forms\" ) browser . get_url () Ahora podemos extraer el contenido de la p\u00e1gina: browser . get_current_page () que devolver\u00e1 el c\u00f3digo fuente de la p\u00e1gina actual de la misma forma que lo hace la funci\u00f3n prettify de beautifulsoup. Recordemos que MechanicalSoup utiliza BeautifulSoup para la extracci\u00f3n de datos. Para encontrar cualquier etiqueta, podr\u00edamos buscarla as\u00ed: browser . get_current_page () . find_all ( 'legend' ) Formularios Tambi\u00e9n podemos encontrar los formularios y hacer peticiones POST con el siguiente comando: browser . select_form ( 'form[action=\"/post\"]' ) browser . get_current_form () . print_summary () Con select_form() utilizamos un selector CSS, seleccionamos el tag HTML form que tiene al atributo action y cuyo valor es /post . print_summary nos mostrar\u00e1 todos los campos disponibles del formulario Para rellenar el formulario, podemos utilizar los siguientes comandos: browser [ \"custname\" ] = \"Mohit\" browser [ \"custtel\" ] = \"9081515151\" browser [ \"custemail\" ] = \"mohitmaithani@aol.com\" browser [ \"comments\" ] = \"please make pizza dough more soft\" browser [ \"size\" ] = \"large\" browser [ \"topping\" ] = \"mushroom\" Y, posteriormente, podemos ejecutar el navegador con: browser . launch_browser () La sintaxis browser[\"marcador\"] = \"texto\" se usa para rellenar un formulario browser.launch_browser() mostrar\u00e1 el resultado en tiempo real Y con esto damos por presentados los fundamentos m\u00e1s b\u00e1sicos de MechanicalSoup. Para una documentaci\u00f3n en profundidad acerca de su funcionamiento y opciones, podemos consultar aqu\u00ed . Haciendo scraping de im\u00e1genes de hackers import mechanicalsoup #(1) browser = mechanicalsoup . StatefulBrowser () url = \"https://www.google.com/imghp?hl=en\" browser . open ( url ) #obtener el HTML browser . get_current_page () #localizar el input para la b\u00fasqueda browser . select_form () browser . get_current_form () . print_summary () #buscar el t\u00e9rmino concreto search_term = 'hacker' browser [ \"q\" ] = search_term #enviar o hacer \"click\" en buscar respuesta = browser . submit_selected () print ( 'nueva url:' , browser . get_url ()) print ( 'respuesta: \\n ' , respuesta . text [: 500 ]) #abrir la URL #(2) nueva_url = browser . get_url () browser . open ( nueva_url ) #obtener el c\u00f3digo HTML page = browser . get_current_page () all_images = page . find_all ( 'img' ) #localizar los atributos de cada imagen image_source = [] for image in all_images : image = image . get ( 'src' ) image_source . append ( image ) image_source [ 5 : 25 ] #guardar los links \"limpios\" en 'image_source' image_source = [ image for image in image_source if image . startswith ( 'https' )] print ( image_source ) import os #(4) path = os . getcwd () path = os . path . join ( path , search_term + \"s\" ) #crear el directorio os . mkdir ( path ) #imprimir el path donde se van a guardar las im\u00e1genes de hackers path ##Descargar wget descomentando la l\u00ednea de abajo #(5) #pip install wget ##descargar im\u00e1genes counter = 0 for image in image_source : save_as = os . path . join ( path , search_term + str ( counter ) + '.jpg' ) wget . download ( image , save_as ) counter += 1 Buscar im\u00e1genes de hackers en Google. Establecemos la petici\u00f3n/query y hacemos que se abra en el navegador con el texto hackers Navegar a las p\u00e1ginas nuevas y apuntar a todas las im\u00e1genes, lo que devolver\u00e1 la lista de todas las URLs Arreglamos las URLs corruptas. La funci\u00f3n de Python startswith permite filtrar las URLs para que no empiecen por HTTPS Crear un repositorio local para guardar las im\u00e1genes Usamos wget para descargar Info MechanicalSoop es una composici\u00f3n de las bibliotecas Requests, BeautifulSoup y teniendo algo de las capacidades de Selenium en cuanto navegaci\u00f3n en tiempo real. Referencias MechanicalSoup tutorial - First contact, step by step A Deep Dive Into Web Scraping Using MechanicalSoup","title":"MechanicalSoup"},{"location":"mechanical/#mechanical-soup","text":"","title":"Mechanical Soup"},{"location":"mechanical/#introduccion","text":"MechanicalSoup es un paquete de Python que, de forma autom\u00e1tica, env\u00eda cookies, sigue redirecciones y tambi\u00e9n puede seguir hiperenlaces o formularios de un sitio web. Fue creado por M. Hickford debido a su fascinaci\u00f3n por la biblioteca Mechanize. Mechanize fue un proyecto de John J. Lee que permitia navegar de forma program\u00e1tica en Python. Algunas de las caracter\u00edsticas de Mechanize eran: mechanize.browser : que usa urllib2.OpenerDirector para abrir una URL de Internet Completado f\u00e1cil de formularios HTML Revisi\u00f3n autom\u00e1tica de robots.txt Manejo autom\u00e1tica de HTTP-Equiv M\u00e9todos de navegador .back() y .reload Desafortunadamente, Mechanize no es compatible con Python3 y, adem\u00e1s, su desarrollo lleva a\u00f1os estancado. En este contexto, Hickford emergi\u00f3 con una soluci\u00f3n: MechanicalSoup que provee la misma API y que est\u00e1 construido sobre las bibliotecas Requests (para las sesiones HTTP) y BeautifulSoup (para datos de navegaci\u00f3n). MechanicalSoup est\u00e1 dise\u00f1ado para imitar el comportamiento de los humanos cuando interact\u00faan con los navegadores web. Algunos de los posibles casos de uso incluyen: Interactuar con sitios web que no proporcionan API Hacer pruebas de un sitio web que se est\u00e9 desarrollando Navegar a trav\u00e9s de una interfaz","title":"Introducci\u00f3n"},{"location":"mechanical/#instalacion-y-comprobacion","text":"Lo primero que deberemos hacer, como siempre, es instalar MechanicalSoup. Podemos hacerlo en nuestro entorno virtual: pipenv shell pipenv install mechanicalsoup O, de forma general, en nuestra m\u00e1quina: pipenv install mechanicalsoup Comprobemos que no tenemos errores con nuestra nueva biblioteca. Para ello, en el entorno interactivo de Python3: import mechanicalsoup browser = mechanicalsoup . StatefulBrowser () url = \"http://httpbin.org\" browser . open ( url ) print ( browser . get_url ()) En el c\u00f3digo de arriba: Importamos la biblioteca mechanicalsoup.StatefulBrowser() crear\u00e1 un objeto de navegador. browser.open() brir\u00e1 la p\u00e1gina deseado en segundo plano y devolver\u00e1 un response[200] que es el valor devuelto por open() . MechanicalSoup usa la biblioteca requests para realizar las peticiones HTTP a los sitios. browser.get_url() recoge la URL del sitio y tambi\u00e9n usa requests","title":"Instalaci\u00f3n y comprobaci\u00f3n"},{"location":"mechanical/#trabajar-con-mechanicalsoup","text":"Siguiendo con el ejemplo anterior, podemos llevar a cabo m\u00e1s acciones, como por ejemplo seguir subdominios de la siguiente forma: browser . follow_link ( \"forms\" ) browser . get_url () Ahora podemos extraer el contenido de la p\u00e1gina: browser . get_current_page () que devolver\u00e1 el c\u00f3digo fuente de la p\u00e1gina actual de la misma forma que lo hace la funci\u00f3n prettify de beautifulsoup. Recordemos que MechanicalSoup utiliza BeautifulSoup para la extracci\u00f3n de datos. Para encontrar cualquier etiqueta, podr\u00edamos buscarla as\u00ed: browser . get_current_page () . find_all ( 'legend' )","title":"Trabajar con MechanicalSoup"},{"location":"mechanical/#formularios","text":"Tambi\u00e9n podemos encontrar los formularios y hacer peticiones POST con el siguiente comando: browser . select_form ( 'form[action=\"/post\"]' ) browser . get_current_form () . print_summary () Con select_form() utilizamos un selector CSS, seleccionamos el tag HTML form que tiene al atributo action y cuyo valor es /post . print_summary nos mostrar\u00e1 todos los campos disponibles del formulario Para rellenar el formulario, podemos utilizar los siguientes comandos: browser [ \"custname\" ] = \"Mohit\" browser [ \"custtel\" ] = \"9081515151\" browser [ \"custemail\" ] = \"mohitmaithani@aol.com\" browser [ \"comments\" ] = \"please make pizza dough more soft\" browser [ \"size\" ] = \"large\" browser [ \"topping\" ] = \"mushroom\" Y, posteriormente, podemos ejecutar el navegador con: browser . launch_browser () La sintaxis browser[\"marcador\"] = \"texto\" se usa para rellenar un formulario browser.launch_browser() mostrar\u00e1 el resultado en tiempo real Y con esto damos por presentados los fundamentos m\u00e1s b\u00e1sicos de MechanicalSoup. Para una documentaci\u00f3n en profundidad acerca de su funcionamiento y opciones, podemos consultar aqu\u00ed .","title":"Formularios"},{"location":"mechanical/#haciendo-scraping-de-imagenes-de-hackers","text":"import mechanicalsoup #(1) browser = mechanicalsoup . StatefulBrowser () url = \"https://www.google.com/imghp?hl=en\" browser . open ( url ) #obtener el HTML browser . get_current_page () #localizar el input para la b\u00fasqueda browser . select_form () browser . get_current_form () . print_summary () #buscar el t\u00e9rmino concreto search_term = 'hacker' browser [ \"q\" ] = search_term #enviar o hacer \"click\" en buscar respuesta = browser . submit_selected () print ( 'nueva url:' , browser . get_url ()) print ( 'respuesta: \\n ' , respuesta . text [: 500 ]) #abrir la URL #(2) nueva_url = browser . get_url () browser . open ( nueva_url ) #obtener el c\u00f3digo HTML page = browser . get_current_page () all_images = page . find_all ( 'img' ) #localizar los atributos de cada imagen image_source = [] for image in all_images : image = image . get ( 'src' ) image_source . append ( image ) image_source [ 5 : 25 ] #guardar los links \"limpios\" en 'image_source' image_source = [ image for image in image_source if image . startswith ( 'https' )] print ( image_source ) import os #(4) path = os . getcwd () path = os . path . join ( path , search_term + \"s\" ) #crear el directorio os . mkdir ( path ) #imprimir el path donde se van a guardar las im\u00e1genes de hackers path ##Descargar wget descomentando la l\u00ednea de abajo #(5) #pip install wget ##descargar im\u00e1genes counter = 0 for image in image_source : save_as = os . path . join ( path , search_term + str ( counter ) + '.jpg' ) wget . download ( image , save_as ) counter += 1 Buscar im\u00e1genes de hackers en Google. Establecemos la petici\u00f3n/query y hacemos que se abra en el navegador con el texto hackers Navegar a las p\u00e1ginas nuevas y apuntar a todas las im\u00e1genes, lo que devolver\u00e1 la lista de todas las URLs Arreglamos las URLs corruptas. La funci\u00f3n de Python startswith permite filtrar las URLs para que no empiecen por HTTPS Crear un repositorio local para guardar las im\u00e1genes Usamos wget para descargar Info MechanicalSoop es una composici\u00f3n de las bibliotecas Requests, BeautifulSoup y teniendo algo de las capacidades de Selenium en cuanto navegaci\u00f3n en tiempo real.","title":"Haciendo scraping de im\u00e1genes de hackers"},{"location":"mechanical/#referencias","text":"MechanicalSoup tutorial - First contact, step by step A Deep Dive Into Web Scraping Using MechanicalSoup","title":"Referencias"},{"location":"modulos/","text":"M\u00f3dulos y Paquetes Introducci\u00f3n Una de las ventajas de las funciones es c\u00f3mo separan los bloques de c\u00f3digo de su programa principal. Utilizando nombres descriptivos para las funciones, el programa principal ser\u00e1 mucho m\u00e1s f\u00e1cil de seguir. Se puede ir un paso m\u00e1s all\u00e1 almacenando las funciones en un archivo separado llamado m\u00f3dulo y luego importando ese m\u00f3dulo en el programa principal. Una declaraci\u00f3n de importaci\u00f3n le dice a Python que el c\u00f3digo de un m\u00f3dulo est\u00e9 disponible en el programa que se est\u00e1 ejecutando. Almacenar funciones en un archivo separado permite ocultar los detalles de del c\u00f3digo del programa y centrarse en la l\u00f3gica de alto nivel. Tambi\u00e9n permite reutilizar las funciones en muchos programas diferentes. Cuando se almacenan funciones en archivos separados, se pueden compartir esos archivos con otros programadores sin tener que compartir todo el programa. Saber c\u00f3mo importar funciones tambi\u00e9n permite utilizar bibliotecas de funciones que otros programadores han escrito. M\u00f3dulos As\u00ed pues, un m\u00f3dulo es un archivo de Python que contiene variables, funciones y clases. Es una forma de ordenar y reutilizar c\u00f3digo ya que todo el contenido de un m\u00f3dulo es accesible por los archivos que lo importen. # mundo.py def hola_mundo (): print ( \"\u00a1Hola Mundo!\" ) def adios_mundo (): print ( \"\u00a1Adios Mundo!\" ) Para acceder a las funciones desde otro archivo Python se utiliza la palabra reservada import : # app.py import mundo # Llamada a la funci\u00f3n mundo . hola_mundo () Tambi\u00e9n existe la posibilidad de importar \u00fanicamente objetos concretos de un m\u00f3dulo mediante la sintaxis from ... import : # app.py from mundo import adios_mundo # Llamada a la funci\u00f3n adios_mundo () De esta forma no es necesario escribir el nombre del modulo antes de utilizar la funci\u00f3n. De igual manera, se pueden importar varios objetos de un m\u00f3dulo separ\u00e1ndolos por una coma: # app.py from mundo import adios_mundo , hola_mundo Para importar todos los los objetos de un m\u00f3dulo basta con utilizar el asterisco: # app.py from mundo import * Localizaci\u00f3n de los m\u00f3dulos Al importar un m\u00f3dulo Python lo buscara en los siguientes directorios: En el directorio actual. En los directorios declarados en el PYTHONPATH (variable de entorno que contiene un listado de directorios) En el directorio de instalaci\u00f3n de Python por defecto (en UNIX normalmente ' /usr/local/lib/python /') Paquetes Es posible agrupar los m\u00f3dulos que tienen relaci\u00f3n en un mismo directorio. Estos directorios son conocidos en Python como paquetes y deben contener siempre un archivo llamado __init__.py para que Python lo reconozca como un paquete. A medida que desarrollamos una aplicaci\u00f3n es habitual agrupar los archivos en directorios (paquetes) para tener el c\u00f3digo organizado. Para cargar un m\u00f3dulo ubicado en un paquete lo haremos de la siguiente forma: import mipaquete.mundo o bien de la siguiente manera: from mipaquete import mundo Tambi\u00e9n es posible importar elementos concretos de un m\u00f3dulo: from mipaquete.mundo import adios_mundo , hola_mundo","title":"M\u00f3dulos y paquetes"},{"location":"modulos/#modulos-y-paquetes","text":"","title":"M\u00f3dulos y Paquetes"},{"location":"modulos/#introduccion","text":"Una de las ventajas de las funciones es c\u00f3mo separan los bloques de c\u00f3digo de su programa principal. Utilizando nombres descriptivos para las funciones, el programa principal ser\u00e1 mucho m\u00e1s f\u00e1cil de seguir. Se puede ir un paso m\u00e1s all\u00e1 almacenando las funciones en un archivo separado llamado m\u00f3dulo y luego importando ese m\u00f3dulo en el programa principal. Una declaraci\u00f3n de importaci\u00f3n le dice a Python que el c\u00f3digo de un m\u00f3dulo est\u00e9 disponible en el programa que se est\u00e1 ejecutando. Almacenar funciones en un archivo separado permite ocultar los detalles de del c\u00f3digo del programa y centrarse en la l\u00f3gica de alto nivel. Tambi\u00e9n permite reutilizar las funciones en muchos programas diferentes. Cuando se almacenan funciones en archivos separados, se pueden compartir esos archivos con otros programadores sin tener que compartir todo el programa. Saber c\u00f3mo importar funciones tambi\u00e9n permite utilizar bibliotecas de funciones que otros programadores han escrito.","title":"Introducci\u00f3n"},{"location":"modulos/#modulos","text":"As\u00ed pues, un m\u00f3dulo es un archivo de Python que contiene variables, funciones y clases. Es una forma de ordenar y reutilizar c\u00f3digo ya que todo el contenido de un m\u00f3dulo es accesible por los archivos que lo importen. # mundo.py def hola_mundo (): print ( \"\u00a1Hola Mundo!\" ) def adios_mundo (): print ( \"\u00a1Adios Mundo!\" ) Para acceder a las funciones desde otro archivo Python se utiliza la palabra reservada import : # app.py import mundo # Llamada a la funci\u00f3n mundo . hola_mundo () Tambi\u00e9n existe la posibilidad de importar \u00fanicamente objetos concretos de un m\u00f3dulo mediante la sintaxis from ... import : # app.py from mundo import adios_mundo # Llamada a la funci\u00f3n adios_mundo () De esta forma no es necesario escribir el nombre del modulo antes de utilizar la funci\u00f3n. De igual manera, se pueden importar varios objetos de un m\u00f3dulo separ\u00e1ndolos por una coma: # app.py from mundo import adios_mundo , hola_mundo Para importar todos los los objetos de un m\u00f3dulo basta con utilizar el asterisco: # app.py from mundo import *","title":"M\u00f3dulos"},{"location":"modulos/#localizacion-de-los-modulos","text":"Al importar un m\u00f3dulo Python lo buscara en los siguientes directorios: En el directorio actual. En los directorios declarados en el PYTHONPATH (variable de entorno que contiene un listado de directorios) En el directorio de instalaci\u00f3n de Python por defecto (en UNIX normalmente ' /usr/local/lib/python /')","title":"Localizaci\u00f3n de los m\u00f3dulos"},{"location":"modulos/#paquetes","text":"Es posible agrupar los m\u00f3dulos que tienen relaci\u00f3n en un mismo directorio. Estos directorios son conocidos en Python como paquetes y deben contener siempre un archivo llamado __init__.py para que Python lo reconozca como un paquete. A medida que desarrollamos una aplicaci\u00f3n es habitual agrupar los archivos en directorios (paquetes) para tener el c\u00f3digo organizado. Para cargar un m\u00f3dulo ubicado en un paquete lo haremos de la siguiente forma: import mipaquete.mundo o bien de la siguiente manera: from mipaquete import mundo Tambi\u00e9n es posible importar elementos concretos de un m\u00f3dulo: from mipaquete.mundo import adios_mundo , hola_mundo","title":"Paquetes"},{"location":"operadores/","text":"Operadores y expresiones Los operadores son s\u00edmbolos especiales que permiten realizar operaciones aritm\u00e9ticas o l\u00f3gicas. Operadores aritm\u00e9ticos Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas (suma, resta, multiplicaci\u00f3n,...). La tabla siguiente contiene todos los operadores aritm\u00e9ticos permitidos por Python: Operador Ejemplo Significado + a + b Suma - a - b Resta - -a Negaci\u00f3n (asignar valor negativo) * a * b Multiplicaci\u00f3n / a / b Divisi\u00f3n % a % b M\u00f3dulo (resto de la divisi\u00f3n) // a // b Divisi\u00f3n entera ** a ** b Exponente Ejemplos: x = 5 y = 2 print ( x + y ) # 7 print ( x - y ) # 3 print ( x * y ) # 10 print ( x / y ) # 2.5 Operadores relacionales o de comparaci\u00f3n Los operadores relacionales se utilizan para comparar valores y devuelven como resultado un booleano: True o False . Operador Ejemplo Significado > a > b Mayor que: True si a es mayor que b < a > b Menor que: True si a es menor que b == a == b Igual: True si a y b son iguales != a != b Distinto: True si a y b son distintos >= a >= b Mayor o igual: True si a es igual o mayor que b <= a >= b Menor o igual: True si a es igual o menor que b Operadores l\u00f3gicos Los operadores l\u00f3gicos and or , y not eval\u00faan valores devolviendo tambi\u00e9n True o False como resultado: Operador Ejemplo Significado and a and b True si a y b son True or a or b True si a o b son true not not b True si b es falso Coding time! Ejercicio 1 Crea un programa que solicite al usuario un n\u00famero del 1 al 10 y muestre por pantalla la tabla de multiplicaci\u00f3n del 1 al 10. Ejemplo: Introduce un n\u00famero del 1 al 10: 3 3 x 1 = 3 3 x 2 = 6 3 x 3 = 9 3 x 4 = 12 3 x 5 = 15 3 x 6 = 18 3 x 7 = 21 3 x 8 = 24 3 x 9 = 27 3 x 10 = 30 Ejercicio 2 Crea un programa que solicite al usuario dos n\u00fameros enteros y muestre por pantalla el resultado de las siguientes operaciones: suma, resta, multiplicaci\u00f3n y divisi\u00f3n. Ejemplo: Introduce el primer n\u00famero: 8 Introduce el segundo n\u00famero: 2 La suma es: 10 La resta es: 6 La multiplicaci\u00f3n es: 16 La divisi\u00f3n es: 4.0 Ejercicio 3 Crea un programa que solicite al usuario el radio de un c\u00edrculo y calcule el \u00e1rea. Nota: Utiliza 3.14159 como n\u00famero PI para el c\u00e1lculo del \u00e1rea. Ejemplo: Introduce el radio: 3 El \u00e1rea es: 28.274309999999996","title":"Operadores"},{"location":"operadores/#operadores-y-expresiones","text":"Los operadores son s\u00edmbolos especiales que permiten realizar operaciones aritm\u00e9ticas o l\u00f3gicas.","title":"Operadores y expresiones"},{"location":"operadores/#operadores-aritmeticos","text":"Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas (suma, resta, multiplicaci\u00f3n,...). La tabla siguiente contiene todos los operadores aritm\u00e9ticos permitidos por Python: Operador Ejemplo Significado + a + b Suma - a - b Resta - -a Negaci\u00f3n (asignar valor negativo) * a * b Multiplicaci\u00f3n / a / b Divisi\u00f3n % a % b M\u00f3dulo (resto de la divisi\u00f3n) // a // b Divisi\u00f3n entera ** a ** b Exponente Ejemplos: x = 5 y = 2 print ( x + y ) # 7 print ( x - y ) # 3 print ( x * y ) # 10 print ( x / y ) # 2.5","title":"Operadores aritm\u00e9ticos"},{"location":"operadores/#operadores-relacionales-o-de-comparacion","text":"Los operadores relacionales se utilizan para comparar valores y devuelven como resultado un booleano: True o False . Operador Ejemplo Significado > a > b Mayor que: True si a es mayor que b < a > b Menor que: True si a es menor que b == a == b Igual: True si a y b son iguales != a != b Distinto: True si a y b son distintos >= a >= b Mayor o igual: True si a es igual o mayor que b <= a >= b Menor o igual: True si a es igual o menor que b","title":"Operadores relacionales o de comparaci\u00f3n"},{"location":"operadores/#operadores-logicos","text":"Los operadores l\u00f3gicos and or , y not eval\u00faan valores devolviendo tambi\u00e9n True o False como resultado: Operador Ejemplo Significado and a and b True si a y b son True or a or b True si a o b son true not not b True si b es falso","title":"Operadores l\u00f3gicos"},{"location":"operadores/#coding-time","text":"","title":"Coding time!"},{"location":"operadores/#ejercicio-1","text":"Crea un programa que solicite al usuario un n\u00famero del 1 al 10 y muestre por pantalla la tabla de multiplicaci\u00f3n del 1 al 10. Ejemplo: Introduce un n\u00famero del 1 al 10: 3 3 x 1 = 3 3 x 2 = 6 3 x 3 = 9 3 x 4 = 12 3 x 5 = 15 3 x 6 = 18 3 x 7 = 21 3 x 8 = 24 3 x 9 = 27 3 x 10 = 30","title":"Ejercicio 1"},{"location":"operadores/#ejercicio-2","text":"Crea un programa que solicite al usuario dos n\u00fameros enteros y muestre por pantalla el resultado de las siguientes operaciones: suma, resta, multiplicaci\u00f3n y divisi\u00f3n. Ejemplo: Introduce el primer n\u00famero: 8 Introduce el segundo n\u00famero: 2 La suma es: 10 La resta es: 6 La multiplicaci\u00f3n es: 16 La divisi\u00f3n es: 4.0","title":"Ejercicio 2"},{"location":"operadores/#ejercicio-3","text":"Crea un programa que solicite al usuario el radio de un c\u00edrculo y calcule el \u00e1rea. Nota: Utiliza 3.14159 como n\u00famero PI para el c\u00e1lculo del \u00e1rea. Ejemplo: Introduce el radio: 3 El \u00e1rea es: 28.274309999999996","title":"Ejercicio 3"},{"location":"requests/","text":"Requests En muchas aplicaciones web es normal conectarse a varios servicios de terceros mediante el uso de APIs. Al utilizar estas APIs puedes acceder a datos como informaci\u00f3n meteorol\u00f3gica, resultados deportivos, listas de pel\u00edculas, tweets, resultados de motores de b\u00fasqueda e im\u00e1genes entre otros ejemplos. Tambi\u00e9n se pueden utilizar las APIs para a\u00f1adir funcionalidad a una aplicaci\u00f3n. Ejemplos de ello son los pagos, la programaci\u00f3n, los correos electr\u00f3nicos, las traducciones, los mapas y las transferencias de archivos. Si tuvieramos que crear cualquiera de ellas por nuestra cuenta, nos llevar\u00eda mucho tiempo, pero con las APIs, podemos tardar s\u00f3lo unos minutos en conectarnos a una y acceder a sus funciones y datos. En esta secci\u00f3n hablaremos sobre la biblioteca Python Requests, que permite enviar peticiones HTTP en Python. Y dado que el uso de una API consiste en enviar peticiones HTTP y recibir respuestas, Requests permite utilizar las API en Python. Entendiendo las peticiones HTTP Las peticiones HTTP son la forma de funcionamiento de la web. Cada vez que navegamos por una p\u00e1gina web, el navegador realiza m\u00faltiples peticiones al servidor web. El servidor responde con todos los datos necesarios para renderizar la p\u00e1gina, y el navegador la renderiza para que podamos verla. El proceso gen\u00e9rico es el siguiente: Un cliente (como un navegador o un script de Python usando Requests) envia algunos datos a una URL. El servidor del sitio web asociado a esa URL leer\u00e1 los datos, decidir\u00e1 qu\u00e9 hacer con ellos y devolver\u00e1 una respuesta al cliente. Finalmente, el cliente puede decidir qu\u00e9 hacer con los datos de la respuesta. Parte de los datos que el cliente env\u00eda en una solicitud es el m\u00e9todo de solicitud. Algunos m\u00e9todos de solicitud comunes son GET , POST y PUT . Las peticiones GET son normalmente para leer datos s\u00f3lo sin hacer un cambio en algo, mientras que las peticiones POST y PUT son generalmente para modificar datos en el servidor. Cuando se env\u00eda una solicitud desde un script de Python o dentro de una aplicaci\u00f3n web, el desarrollador puede decidir qu\u00e9 se env\u00eda en cada solicitud y qu\u00e9 se hace con la respuesta. Instalando requests Podemos o bien instalar de forma global la biblioteca: pipenv install requests O bien, utilizar un entorno virtual a tal efecto. Creamos una carpeta para hacer la prueba: mkdir prueba_r Dentro de la carpeta, ejecutamos un nuevo entorno virtual: pipenv shell Y, una vez dentro, instalamos la biblioteca: pipenv install requests Probando requests Si entramos en el entorno interactivo de Python: python3 Podemos empezar a jugar con la biblioteca. El primer paso ser\u00e1 importar requests para poder utilizarlo realizando nuestra primera petici\u00f3n GET a una URL e imprimiendo la respuesta (o mejor dicho, su c\u00f3digo HTTP): >>> import requests >>> r = requests . get ( 'https://raul-profesor.github.io' ) >>> print ( r ) < Response [ 200 ] > >>> Por mera curiosidad, vamos a ver qu\u00e9 tipo de dato es r : >>> print ( type ( r )) < class ' requests . models . Response '> Lo que nos dice es que es una instancia de la clase Response . El objeto Response contiene el resultado de la petici\u00f3n HTTP. Nota Para los ejemplos utilizaremos el sitio web httpbin.org . La herramienta httpbin es un servicio gratuito y sencillo de petici\u00f3n y respuesta HTTP que proporciona un conjunto de endpoints URL. Utilizamos estos endpoints para probar varias formas de trabajar con operaciones HTTP. Utilizaremos la herramienta httpbin porque nos ayuda a centrarnos en el aprendizaje de la biblioteca Python Requests sin necesidad de configurar un servidor web real o utilizar un servicio web en l\u00ednea. Peticiones GET Utilizaremos las peticiones GET para solicitar datos de un servidor web concreto. Probemos: url = 'http://httpbin.org/json' r = requests . get ( url ) print ( 'Response Code:' , r . status_code ) print ( 'Response Headers: \\n ' , r . headers ) print ( 'Response Content: \\n ' , r . text ) Ejecutando el c\u00f3digo de arriba obtenemos un c\u00f3dido de estado 200, el cual indica que la URL es alcanzable o accesible. Tambi\u00e9n devuelve los datos de las cabeceras de la p\u00e1gina, seguido del contenido de la p\u00e1gina. La propiedad headers devuelve un diccionario especial hecho s\u00f3lo para cabeceras HTTP, de tal forma que podamos acceder a cada elemento simplemente usando su key o clave: print ( r . headers [ 'Content-Type' ]) Ejecutando el comando de arriba, nos devolver\u00e1 que el tipo de contenido de la p\u00e1gina es application/json . En la \u00faltima l\u00ednea del c\u00f3digo, podemos utilizar la propiedad content que devuelve el contenido de la p\u00e1gina como una serie de bytes, pero preferiremos usar la propiedad text que imprime por pantalla dicho contenido como texto decodificado en formato Unicode. Usando par\u00e1metros GET Usamos los par\u00e1metros GET para pasar informaci\u00f3n en formato de parejas clave-valor hacia un servidor web a trav\u00e9s de una URL. El m\u00e9todo get nos permite pasar un diccionario de claves-valores usando el argumento params . Intentemoslo: url = 'http://httpbin.org/get' payload = { 'website' : 'dataquest.io' , 'courses' :[ 'Python' , 'SQL' ] } r = requests . get ( url , params = payload ) print ( 'Response Content: \\n ' , r . text ) Corriendo el c\u00f3digo de arriba, se obtiene una respuesta como esta: Respo nse Co ntent : { \"args\" : { \"courses\" : [ \"Python\" , \"SQL\" ], \"website\" : \"dataquest.io\" }, \"headers\" : { \"Accept\" : \"*/*\" , \"Accept-Encoding\" : \"gzip, deflate\" , \"Host\" : \"httpbin.org\" , \"User-Agent\" : \"python-requests/2.27.1\" , \"X-Amzn-Trace-Id\" : \"Root=1-61e7e066-5d0cacfb49c3c1c3465bbfb2\" }, \"origin\" : \"172.123.65.155\" , \"url\" : \"http://httpbin.org/get?website=dataquest.io&courses=Python&courses=SQL\" } El contenido de la respuesta est\u00e1 en formato JSON y el par clave-valor que le pasamos a trav\u00e9s del argumento params aparece en la secci\u00f3n args de la respuesta. Tambi\u00e9n la secci\u00f3n url contiene la URL codificada junto con los par\u00e1metros que se le han pasado al servidor. Peticiones POST Usamos la petici\u00f3n POST para enviar datos recogidos de un formulario web a un servidor web. Para llevar a cabo esto con la biblioteca requests, primero necesitamos crear un diccionario de datos y asignarlo al argumento data del m\u00e9todo post: url = 'http://httpbin.org/post' payload = { 'website' : 'dataquest.io' , 'courses' :[ 'Python' , 'SQL' ] } r = requests . post ( url , data = payload ) print ( 'Response Content: \\n ' , r . text ) Corriendo el c\u00f3digo de arriba, se obtiene una respuesta como esta: Respo nse Co ntent : { \"args\" : {}, \"data\" : \"\" , \"files\" : {}, \"form\" : { \"courses\" : [ \"Python\" , \"SQL\" ], \"website\" : \"dataquest.io\" }, \"headers\" : { \"Accept\" : \"*/*\" , \"Accept-Encoding\" : \"gzip, deflate\" , \"Content-Length\" : \"47\" , \"Content-Type\" : \"application/x-www-form-urlencoded\" , \"Host\" : \"httpbin.org\" , \"User-Agent\" : \"python-requests/2.27.1\" , \"X-Amzn-Trace-Id\" : \"Root=1-61e7ec9f-6333082d7f0b73d317acc1f6\" }, \"json\" : null , \"origin\" : \"172.123.65.155\" , \"url\" : \"http://httpbin.org/post\" } Esta vez los datos enviados a trav\u00e9s del m\u00e9todo post aparecen en la secci\u00f3n form de la respuesta, en lugar de en args porque en vez de enviar los datos como par\u00e1metros dentro de la URL, los enviamos como datos codificados de un formulario. Manejando excepciones Cuando nos comunicamos con un servidor remoto, pueden ocurrir excepciones. Por ejemplo, el servidor puede ser inalcanzable, la URL no existir en el servidor, o el servidor no responder en un marco de tiempo adecuado. Veamos como detectar y resolver errores HTTP usando la clase HTTPError de la biblioteca requests: import requests from requests import HTTPError url = \"http://httpbin.org/status/404\" try : r = requests . get ( url ) r . raise_for_status () print ( 'Response Code:' , r . status_code ) except HTTPError as ex : print ( ex ) En el c\u00f3digo de arriba, importamos la clase HTTPError para capturar y resolver las excepciones HTTP. Tras ello, realizamos una petici\u00f3n a un endpoint en httpbin.org , el cual genera un c\u00f3digo de estado 404. El m\u00e9todo raise_for_status() genera una excepci\u00f3n siempre que la respuesta HTTP contenga un c\u00f3dio de error (un error de cliente del tipo 4XX o una respuesta de error del servidor del tipo 5XX). La biblioteca requests no genera una excepci\u00f3n autom\u00e1ticamente una vez ocurre un error. Es por ello que necesitamos usaro el m\u00e9todo raise_for_status() para identificar si un c\u00f3digo de estado de error ha ocurrido o no. Finalmente, el manejador de excepciones bloquea la captura del error y lo imprime tal que as\u00ed: 404 Client Error: NOT FOUND for url: http://httpbin.org/status/404 Note Si intentamos acceder al endpoint http://httpbin.org/status/200 , la salida del c\u00f3digo de arriba ser\u00e1 Response Code: 200 porque el c\u00f3digo de estado no est\u00e1 en el rango de c\u00f3digos de estado de error. El m\u00e9todo raise_for_status() devolver\u00e1 None , que no har\u00e1 saltar al manejador de excepciones. Adem\u00e1s del manejo de excepciones que acabamos de ver, veremos c\u00f3mo resolver los timeouts . Esto es crucial porque necesitaremos asegurarnos de que nuestra aplicaci\u00f3n no se queda esperando indefinidamente. Si una petici\u00f3n agota el tiempo de espera, produce una excepci\u00f3n del timpo Timeout . Para especificar qu\u00e9 n\u00famero de segundos consideraremos como timeout, podemos usar el argumento timeout : import requests from requests import Timeout url = \"http://httpbin.org/delay/10\" try : r = requests . get ( url , timeout = 3 ) print ( 'Response Code:' , r . status_code ) except Timeout as ex : print ( ex ) En primer lugar importamos la clase Timeout para resolver la excepciones de tipo timeout y proporcionarnamos una URL que hace referencia a un endpoint con un delay de 10 segundos para probar nuestro c\u00f3digo. Tras esto, establecemos el argumento timeout a un valor de 3 segundos, lo que provocar\u00e1 que si el servidor no resuelve la petici\u00f3n get en 3 segundos, se genere una excepci\u00f3n. El manejador de excepciones capturar\u00e1 cualquier error de timeout y lo mostrar\u00e1. As\u00ed pues, el c\u00f3digo de arriba b\u00e1sicamente muestra el siguiente mensaje d error porque el servidor no responder\u00e1 en el tiempo indicado: HTTPConnectionPool(host='httpbin.org', port=80): Read timed out. (read timeout=3) Autenticaci\u00f3n La bibliotca requests soporta varios tipos de autenticaci\u00f3n web, como la autenticaci\u00f3n b\u00e1sica, digest, las dos versiones de 0Auth... Podemos usar estos m\u00e9todos de autenticaci\u00f3n cuando queramos trabajar con cualquier tipo de fuente de datos que requiera loguearnos. Implementaremos la autenticaci\u00f3n b\u00e1sica usando HTTPBin con el siguiente ejemplo. El endpoint para la autenticaci\u00f3n b\u00e1sica es /basic-auth/{*user*}/{*password*} . Por ejemplo, si quisi\u00e9ramos usar el siguiente endpoint: http://httpbin.org/basic-auth/data/quest , podemos autenticarnos utilizando el utilizando el nombre data y el password quest asign\u00e1ndolos como una tupla al argumento auth . Una vez autenticados satisfactoriamente, nos responder\u00e1 con los datos en formato JSON: { \"authenticated\": true, \"user\": \"data\"} As\u00ed pues, ejecutando el siguiente c\u00f3digo: import requests r = requests . get ( 'http://httpbin.org/basic-auth/data/quest' , auth = ( 'data' , 'quest' )) print ( 'Response Code:' , r . status_code ) print ( 'Response Content: \\n ' , r . text ) Obtenemos la siguiente salida: Response Code: 200 Response Content: { \"authenticated\": true, \"user\": \"data\" } Si introducimos un nombre de usuario o un password incorrecto, la salida mostrar\u00e1: Response Code: 401 Response Content: Referencias Documentaci\u00f3n de biblioteca requests Tutorial: An Introduction to Python Requests Library","title":"Requests"},{"location":"requests/#requests","text":"En muchas aplicaciones web es normal conectarse a varios servicios de terceros mediante el uso de APIs. Al utilizar estas APIs puedes acceder a datos como informaci\u00f3n meteorol\u00f3gica, resultados deportivos, listas de pel\u00edculas, tweets, resultados de motores de b\u00fasqueda e im\u00e1genes entre otros ejemplos. Tambi\u00e9n se pueden utilizar las APIs para a\u00f1adir funcionalidad a una aplicaci\u00f3n. Ejemplos de ello son los pagos, la programaci\u00f3n, los correos electr\u00f3nicos, las traducciones, los mapas y las transferencias de archivos. Si tuvieramos que crear cualquiera de ellas por nuestra cuenta, nos llevar\u00eda mucho tiempo, pero con las APIs, podemos tardar s\u00f3lo unos minutos en conectarnos a una y acceder a sus funciones y datos. En esta secci\u00f3n hablaremos sobre la biblioteca Python Requests, que permite enviar peticiones HTTP en Python. Y dado que el uso de una API consiste en enviar peticiones HTTP y recibir respuestas, Requests permite utilizar las API en Python.","title":"Requests"},{"location":"requests/#entendiendo-las-peticiones-http","text":"Las peticiones HTTP son la forma de funcionamiento de la web. Cada vez que navegamos por una p\u00e1gina web, el navegador realiza m\u00faltiples peticiones al servidor web. El servidor responde con todos los datos necesarios para renderizar la p\u00e1gina, y el navegador la renderiza para que podamos verla. El proceso gen\u00e9rico es el siguiente: Un cliente (como un navegador o un script de Python usando Requests) envia algunos datos a una URL. El servidor del sitio web asociado a esa URL leer\u00e1 los datos, decidir\u00e1 qu\u00e9 hacer con ellos y devolver\u00e1 una respuesta al cliente. Finalmente, el cliente puede decidir qu\u00e9 hacer con los datos de la respuesta. Parte de los datos que el cliente env\u00eda en una solicitud es el m\u00e9todo de solicitud. Algunos m\u00e9todos de solicitud comunes son GET , POST y PUT . Las peticiones GET son normalmente para leer datos s\u00f3lo sin hacer un cambio en algo, mientras que las peticiones POST y PUT son generalmente para modificar datos en el servidor. Cuando se env\u00eda una solicitud desde un script de Python o dentro de una aplicaci\u00f3n web, el desarrollador puede decidir qu\u00e9 se env\u00eda en cada solicitud y qu\u00e9 se hace con la respuesta.","title":"Entendiendo las peticiones HTTP"},{"location":"requests/#instalando-requests","text":"Podemos o bien instalar de forma global la biblioteca: pipenv install requests O bien, utilizar un entorno virtual a tal efecto. Creamos una carpeta para hacer la prueba: mkdir prueba_r Dentro de la carpeta, ejecutamos un nuevo entorno virtual: pipenv shell Y, una vez dentro, instalamos la biblioteca: pipenv install requests","title":"Instalando requests"},{"location":"requests/#probando-requests","text":"Si entramos en el entorno interactivo de Python: python3 Podemos empezar a jugar con la biblioteca. El primer paso ser\u00e1 importar requests para poder utilizarlo realizando nuestra primera petici\u00f3n GET a una URL e imprimiendo la respuesta (o mejor dicho, su c\u00f3digo HTTP): >>> import requests >>> r = requests . get ( 'https://raul-profesor.github.io' ) >>> print ( r ) < Response [ 200 ] > >>> Por mera curiosidad, vamos a ver qu\u00e9 tipo de dato es r : >>> print ( type ( r )) < class ' requests . models . Response '> Lo que nos dice es que es una instancia de la clase Response . El objeto Response contiene el resultado de la petici\u00f3n HTTP. Nota Para los ejemplos utilizaremos el sitio web httpbin.org . La herramienta httpbin es un servicio gratuito y sencillo de petici\u00f3n y respuesta HTTP que proporciona un conjunto de endpoints URL. Utilizamos estos endpoints para probar varias formas de trabajar con operaciones HTTP. Utilizaremos la herramienta httpbin porque nos ayuda a centrarnos en el aprendizaje de la biblioteca Python Requests sin necesidad de configurar un servidor web real o utilizar un servicio web en l\u00ednea.","title":"Probando requests"},{"location":"requests/#peticiones-get","text":"Utilizaremos las peticiones GET para solicitar datos de un servidor web concreto. Probemos: url = 'http://httpbin.org/json' r = requests . get ( url ) print ( 'Response Code:' , r . status_code ) print ( 'Response Headers: \\n ' , r . headers ) print ( 'Response Content: \\n ' , r . text ) Ejecutando el c\u00f3digo de arriba obtenemos un c\u00f3dido de estado 200, el cual indica que la URL es alcanzable o accesible. Tambi\u00e9n devuelve los datos de las cabeceras de la p\u00e1gina, seguido del contenido de la p\u00e1gina. La propiedad headers devuelve un diccionario especial hecho s\u00f3lo para cabeceras HTTP, de tal forma que podamos acceder a cada elemento simplemente usando su key o clave: print ( r . headers [ 'Content-Type' ]) Ejecutando el comando de arriba, nos devolver\u00e1 que el tipo de contenido de la p\u00e1gina es application/json . En la \u00faltima l\u00ednea del c\u00f3digo, podemos utilizar la propiedad content que devuelve el contenido de la p\u00e1gina como una serie de bytes, pero preferiremos usar la propiedad text que imprime por pantalla dicho contenido como texto decodificado en formato Unicode.","title":"Peticiones GET"},{"location":"requests/#usando-parametros-get","text":"Usamos los par\u00e1metros GET para pasar informaci\u00f3n en formato de parejas clave-valor hacia un servidor web a trav\u00e9s de una URL. El m\u00e9todo get nos permite pasar un diccionario de claves-valores usando el argumento params . Intentemoslo: url = 'http://httpbin.org/get' payload = { 'website' : 'dataquest.io' , 'courses' :[ 'Python' , 'SQL' ] } r = requests . get ( url , params = payload ) print ( 'Response Content: \\n ' , r . text ) Corriendo el c\u00f3digo de arriba, se obtiene una respuesta como esta: Respo nse Co ntent : { \"args\" : { \"courses\" : [ \"Python\" , \"SQL\" ], \"website\" : \"dataquest.io\" }, \"headers\" : { \"Accept\" : \"*/*\" , \"Accept-Encoding\" : \"gzip, deflate\" , \"Host\" : \"httpbin.org\" , \"User-Agent\" : \"python-requests/2.27.1\" , \"X-Amzn-Trace-Id\" : \"Root=1-61e7e066-5d0cacfb49c3c1c3465bbfb2\" }, \"origin\" : \"172.123.65.155\" , \"url\" : \"http://httpbin.org/get?website=dataquest.io&courses=Python&courses=SQL\" } El contenido de la respuesta est\u00e1 en formato JSON y el par clave-valor que le pasamos a trav\u00e9s del argumento params aparece en la secci\u00f3n args de la respuesta. Tambi\u00e9n la secci\u00f3n url contiene la URL codificada junto con los par\u00e1metros que se le han pasado al servidor.","title":"Usando par\u00e1metros GET"},{"location":"requests/#peticiones-post","text":"Usamos la petici\u00f3n POST para enviar datos recogidos de un formulario web a un servidor web. Para llevar a cabo esto con la biblioteca requests, primero necesitamos crear un diccionario de datos y asignarlo al argumento data del m\u00e9todo post: url = 'http://httpbin.org/post' payload = { 'website' : 'dataquest.io' , 'courses' :[ 'Python' , 'SQL' ] } r = requests . post ( url , data = payload ) print ( 'Response Content: \\n ' , r . text ) Corriendo el c\u00f3digo de arriba, se obtiene una respuesta como esta: Respo nse Co ntent : { \"args\" : {}, \"data\" : \"\" , \"files\" : {}, \"form\" : { \"courses\" : [ \"Python\" , \"SQL\" ], \"website\" : \"dataquest.io\" }, \"headers\" : { \"Accept\" : \"*/*\" , \"Accept-Encoding\" : \"gzip, deflate\" , \"Content-Length\" : \"47\" , \"Content-Type\" : \"application/x-www-form-urlencoded\" , \"Host\" : \"httpbin.org\" , \"User-Agent\" : \"python-requests/2.27.1\" , \"X-Amzn-Trace-Id\" : \"Root=1-61e7ec9f-6333082d7f0b73d317acc1f6\" }, \"json\" : null , \"origin\" : \"172.123.65.155\" , \"url\" : \"http://httpbin.org/post\" } Esta vez los datos enviados a trav\u00e9s del m\u00e9todo post aparecen en la secci\u00f3n form de la respuesta, en lugar de en args porque en vez de enviar los datos como par\u00e1metros dentro de la URL, los enviamos como datos codificados de un formulario.","title":"Peticiones POST"},{"location":"requests/#manejando-excepciones","text":"Cuando nos comunicamos con un servidor remoto, pueden ocurrir excepciones. Por ejemplo, el servidor puede ser inalcanzable, la URL no existir en el servidor, o el servidor no responder en un marco de tiempo adecuado. Veamos como detectar y resolver errores HTTP usando la clase HTTPError de la biblioteca requests: import requests from requests import HTTPError url = \"http://httpbin.org/status/404\" try : r = requests . get ( url ) r . raise_for_status () print ( 'Response Code:' , r . status_code ) except HTTPError as ex : print ( ex ) En el c\u00f3digo de arriba, importamos la clase HTTPError para capturar y resolver las excepciones HTTP. Tras ello, realizamos una petici\u00f3n a un endpoint en httpbin.org , el cual genera un c\u00f3digo de estado 404. El m\u00e9todo raise_for_status() genera una excepci\u00f3n siempre que la respuesta HTTP contenga un c\u00f3dio de error (un error de cliente del tipo 4XX o una respuesta de error del servidor del tipo 5XX). La biblioteca requests no genera una excepci\u00f3n autom\u00e1ticamente una vez ocurre un error. Es por ello que necesitamos usaro el m\u00e9todo raise_for_status() para identificar si un c\u00f3digo de estado de error ha ocurrido o no. Finalmente, el manejador de excepciones bloquea la captura del error y lo imprime tal que as\u00ed: 404 Client Error: NOT FOUND for url: http://httpbin.org/status/404 Note Si intentamos acceder al endpoint http://httpbin.org/status/200 , la salida del c\u00f3digo de arriba ser\u00e1 Response Code: 200 porque el c\u00f3digo de estado no est\u00e1 en el rango de c\u00f3digos de estado de error. El m\u00e9todo raise_for_status() devolver\u00e1 None , que no har\u00e1 saltar al manejador de excepciones. Adem\u00e1s del manejo de excepciones que acabamos de ver, veremos c\u00f3mo resolver los timeouts . Esto es crucial porque necesitaremos asegurarnos de que nuestra aplicaci\u00f3n no se queda esperando indefinidamente. Si una petici\u00f3n agota el tiempo de espera, produce una excepci\u00f3n del timpo Timeout . Para especificar qu\u00e9 n\u00famero de segundos consideraremos como timeout, podemos usar el argumento timeout : import requests from requests import Timeout url = \"http://httpbin.org/delay/10\" try : r = requests . get ( url , timeout = 3 ) print ( 'Response Code:' , r . status_code ) except Timeout as ex : print ( ex ) En primer lugar importamos la clase Timeout para resolver la excepciones de tipo timeout y proporcionarnamos una URL que hace referencia a un endpoint con un delay de 10 segundos para probar nuestro c\u00f3digo. Tras esto, establecemos el argumento timeout a un valor de 3 segundos, lo que provocar\u00e1 que si el servidor no resuelve la petici\u00f3n get en 3 segundos, se genere una excepci\u00f3n. El manejador de excepciones capturar\u00e1 cualquier error de timeout y lo mostrar\u00e1. As\u00ed pues, el c\u00f3digo de arriba b\u00e1sicamente muestra el siguiente mensaje d error porque el servidor no responder\u00e1 en el tiempo indicado: HTTPConnectionPool(host='httpbin.org', port=80): Read timed out. (read timeout=3)","title":"Manejando excepciones"},{"location":"requests/#autenticacion","text":"La bibliotca requests soporta varios tipos de autenticaci\u00f3n web, como la autenticaci\u00f3n b\u00e1sica, digest, las dos versiones de 0Auth... Podemos usar estos m\u00e9todos de autenticaci\u00f3n cuando queramos trabajar con cualquier tipo de fuente de datos que requiera loguearnos. Implementaremos la autenticaci\u00f3n b\u00e1sica usando HTTPBin con el siguiente ejemplo. El endpoint para la autenticaci\u00f3n b\u00e1sica es /basic-auth/{*user*}/{*password*} . Por ejemplo, si quisi\u00e9ramos usar el siguiente endpoint: http://httpbin.org/basic-auth/data/quest , podemos autenticarnos utilizando el utilizando el nombre data y el password quest asign\u00e1ndolos como una tupla al argumento auth . Una vez autenticados satisfactoriamente, nos responder\u00e1 con los datos en formato JSON: { \"authenticated\": true, \"user\": \"data\"} As\u00ed pues, ejecutando el siguiente c\u00f3digo: import requests r = requests . get ( 'http://httpbin.org/basic-auth/data/quest' , auth = ( 'data' , 'quest' )) print ( 'Response Code:' , r . status_code ) print ( 'Response Content: \\n ' , r . text ) Obtenemos la siguiente salida: Response Code: 200 Response Content: { \"authenticated\": true, \"user\": \"data\" } Si introducimos un nombre de usuario o un password incorrecto, la salida mostrar\u00e1: Response Code: 401 Response Content:","title":"Autenticaci\u00f3n"},{"location":"requests/#referencias","text":"Documentaci\u00f3n de biblioteca requests Tutorial: An Introduction to Python Requests Library","title":"Referencias"},{"location":"variables/","text":"Variables Valores Un valor es una de las cosas b\u00e1sicas que utiliza un programa, como una letra o un n\u00famero. Los valores que hemos visto hasta ahora han sido 1, 2, y \u201c\u00a1Hola, mundo!\u201d Esos valores pertenecen a tipos diferentes: 2 es un entero int , y \u201c \u00a1Hola, mundo! \u201d es una cadena string , que recibe ese nombre porque contiene una cadena de letras. Vosotros (y el int\u00e9rprete) podr\u00e9is identificar las cadenas porque van encerradas entre comillas. Variables y tipos de datos Una de las caracter\u00edsticas m\u00e1s potentes de un lenguaje de programaci\u00f3n es la capacidad de manipular variables. Una variable es un nombre que se refiere a un valor. Una sentencia de asignaci\u00f3n crea variables nuevas y les da valores: En Python cada valor que exista, tiene un tipo de dato, pero no es necesario declarar el tipo de las variables. \u00bfComo funciona? Basado en cada asignaci\u00f3n a la variable, Python deduce el tipo que es y lo conserva internamente. Python proporciona muchos tipos de dato nativos. A continuaci\u00f3n se muestran los m\u00e1s importantes: Booleanos: Su valor es True o False. N\u00fameros: Pueden ser enteros (1, 2, 3,...), flotantes (1.1, 1.2, 1.3,...) 1 , fracciones (1/2, 1/3, 2/3,...), o incluso n\u00fameros complejos (ra\u00edz de -1). Cadenas : Son secuencias de caracteres Unicode, por ejemplo, un documento HTML. Como tipos de datos, destacaremos: Bytes y arrays de bytes: por ejemplo, un fichero de im\u00e1genes JPEG. Listas: Son secuencias ordenadas de valores. Tuplas: Son secuencias ordenadas e inmutables de valores. Conjuntos: Son \u201cbolsas\u201d de valores sin ordenar. Diccionarios: Son \u201cbolsas\u201d de sin ordenar de parejas clave-valor. Es posible buscar directamente por clave. En la imagen anterior ve\u00edamos que ten\u00edamos valores de tipo n\u00famero entero int , de tipo coma flotante float , as\u00ed como una cadena de tipo string str . El nombre de una variable se conoce como identificador , y deber\u00e1 cumplir las siguientes reglas: Comenzar con una letra o un gui\u00f3n bajo. El resto del nombre estar\u00e1 formado por letras, n\u00fameros o guiones bajos. Los nombres de las variables son case sensitive , es decir, no es lo mismo que una variable se llame resultado que RESULTADO . Existen una serie de palabras reservadas que no se pueden utilizar: Algunas de las recomendaciones respecto a los nombres de las variables est\u00e1n recogidas en la Gu\u00eda oficial de Estilos PEP8 de Python . Entre las m\u00e1s habituales encontramos las siguientes: Utilizar nombres descriptivos, en min\u00fasculas y separados por guiones bajos si fuese necesario: resultado , mi_variable , valor_anterior ,... Escribir las constantes en may\u00fasculas: MI_CONSTANTE , NUMERO_PI , ... Antes y despu\u00e9s del signo = , debe haber uno (y solo un) espacio en blanco. Nota No olvideis que lo que la gu\u00eda plantea son recomendaciones y no obligaciones. Por ejemplo, mientras PEP8 recomienda tabular el c\u00f3digo con 4 espacioes en blanco, la gu\u00eda particular de los desarrolladores de Google habla de 2 espacios en lugar de 4. Lectura de datos en Python La funci\u00f3n input() permite introducir datos al usuario: >>> nombre = input () Leire >>> print ( nombre ) Leire Como se puede ver en el siguiente ejemplo, es posible tambi\u00e9n mostrar un mensaje al usuario, tal y como muestra el siguiente ejemplo. >>> nombre = input ( \"Escribe tu nombre: \" ) Escribe tu nombre : Leire >>> print ( nombre ) Leire N\u00fameros Python soporta dos tipos de n\u00fameros: enteros (integer) y de punto flotante (float). ```python integer x = 5 print(x) float y = 5.0 print(y) Otra forma de declarar un float z = float(5) print(z) Si tenemos dudas del valor de una variable, podemos mostrar su tipo utilizando la funci\u00f3n `type()`: ```python >>> x = 5.5 >>> type(x) <class 'float'> Cadenas de texto (string) Las cadenas de texto o strings se definen mediante comilla simple ( ' ' ) o doble comilla ( \" \" ): mi_nombre = 'Ane' print ( mi_nombre ) mi_nombre = \"Ane\" print ( mi_nombre ) La diferencia principal se encuentra en que las comillas dobles aportan mayor facilidad en textos que incluyan ap\u00f3strofes: mi_nombre = 'I \\' m John' print ( mi_nombre ) mi_nombre = \"I'm John\" print ( mi_nombre ) M\u00e1s informaci\u00f3n sobre strings y car\u00e1cteres especiales en: https://docs.python.org/3/tutorial/introduction.html#strings Para definir strings multi-l\u00ednea se utiliza la triples comillas ( \"\"\" ): frase = \"\"\" esto es una frase muy larga de m\u00e1s de una l\u00ednea ...\"\"\" Concatenaci\u00f3n de strings Es posible unir dos strings con el operador + : >>> primera_palabra = 'Hola' >>> frase_completa = primera_palabra + ', mundo' >>> print ( frase_completa ) 'Hola, mundo' >>> segunda_palabra = 'mundo' >>> frase_completa = primera_palabra + ', ' + segunda_palabra >>> print ( frase_completa ) 'Hola, mundo' M\u00e9todo alternativo 1 : str.join(): El m\u00e9todo join() recibe como argumento el listado (de tipo List, Tuple, String, Dictionary y Set) de strings que se desean concatenar. Se invoca sobre el separador que se utilizar\u00e1 para unir las cadenas (el cual a su vez es un string tambi\u00e9n): >>> strings = [ 'do' , 're' , 'mi' ] >>> separador = ' - ' >>> separador . join ( strings ) 'do - re - mi' Para iterar un elemento detr\u00e1s del otro se introducir\u00e1 string vac\u00edo como separador: >>> strings = [ 'do' , 're' , 'mi' ] >>> '' . join ( strings ) 'doremi' M\u00e9todo alternativo 2 : str.format() : Python 3 introdujo una nueva forma para formatear strings, la cual sustituye a la anterior en la que se hace uso del operador % . Para ello se invoca el m\u00e9todo format() de un string: # Ordenado por defecto: frase = \"Meses: {} , {} y {} \" . format ( 'Enero' , 'Febrero' , 'Marzo' ) print ( frase ) # Especificar el orden indicando la posici\u00f3n: frase = \"Meses: {1} , {0} y {2} \" . format ( 'Enero' , 'Febrero' , 'Marzo' ) print ( frase ) # Especificar el orden mediante parejas clave-valor: frase = \"Meses: {ene} , {feb} y {mar} \" . format ( ene = 'Enero' , feb = 'Febrero' , mar = 'Marzo' ) print ( frase ) Cadenas 'f' (f-strings) La versi\u00f3n 3.6 de Python trajo un gran avance a la hora de integrar variables o expreiones en cadenas de car\u00e1cteres. Se introdujeron las llamadas f-strings , una forma m\u00e1s c\u00f3moda y directa para insertar variables y expresiones en cadenas. Permiten introducir cualquier variable o expresi\u00f3n dentro de un string incluyendo la variable entre llaves { y } . Veamos un ejemplo: nombre = \"Nora\" edad = 22 saludo = f \"Me llamo { nombre } y tengo { edad } a\u00f1os.\" Para indicar que se trata de un f-string , este deber\u00e1 incluir la letra 'f' antes del comiendo de la cadena (antes de las comillas). A continuaci\u00f3n se muestra otro ejemplo en el que se introduce una expresi\u00f3n: a = 4 b = 3 print ( f \"La multiplicaci\u00f3n de { a } y { b } es igual a { a * b } \" ) Conversi\u00f3n de tipos A la hora de concatenar un string con otras variables como integer o float puede haber problemas: >>> edad = 25 >>> nota_media = 7.3 >>> print ( \"Tengo \" + edad + \" a\u00f1os y mi nota media es \" + nota_media + \".\" ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : can only concatenate str ( not \"int\" ) to str Mediante la funci\u00f3n str() podemos convertir un valor a string y evitar as\u00ed cualquier tipo de problema: >>> edad = 25 >>> nota_media = 7.3 >>> print ( \"Tengo \" + str ( edad ) + \" a\u00f1os y mi nota media es \" + str ( nota_media ) + \".\" ) Tengo 25 a\u00f1os y mi nota media es 7.3 . De igual manera es posible convertir a otros tipos con las funciones int() , float() and bool() . M\u00e9todos en cadenas de texto (string) Es posible obtener un car\u00e1cter concreto de un string utilizando los corchetes [] y el \u00edndice del car\u00e1cter al que queremos acceder: frase = 'Aprendiendo a programar en Python' frase [ 0 ] # devuelve el primer caracter frase [ 1 ] # devuelve el segundo caracter frase [ - 1 ] # devuelve el primer caracter empezando por el final frase [ - 2 ] # # devuelve el segundo caracter empezando por el final Si queremos obtener un substring , utilizaremos la siguiente notaci\u00f3n: frase = 'Aprendiendo a programar en Python' mi_substring = frase [ 1 : 5 ] # devuelver\u00e1 los caracteres desde la posici\u00f3n 1 hasta la 5 (no incluye el 5) En caso de dejar la primera variable vac\u00eda, se considera la primera posici\u00f3n del string. Dejando la segunda variable vac\u00eda se considera la \u00faltima posici\u00f3n del string: >>> frase = 'Aprendiendo a programar en Python' >>> mi_substring = frase [: 5 ] >>> mi_substring 'Apren' >>> mi_substring = frase [ 4 :] >>> mi_substring 'ndiendo a programar en Python' Otros m\u00e9todos \u00fatiles de string: len ( str ) # devuelve la longitud del string str . upper () # convierte a may\u00fasculas str . lower () # convierte a min\u00fasculas str . title () # convierte a may\u00fasculas la primera letra de cada palabra str . count ( substring [, inicio , fin ]) # devuelve el n\u00famero de veces que aparece # el substring en el string. Opcionalmente se puede indicar el inicio y fin. str . find ( \u2018 d \u2019 ) # devuelve el \u00edndice de la primera aparici\u00f3n de 'd' # (devolver\u00e1 -1 si no lo encuentra) substr in str # devuelve True si el string contiene el substring str . replace ( old , new [, count ]) # reemplaza 'old' por 'new' un m\u00e1ximo de 'count' veces. str . isnumeric () # devuelve True si str contiene solamente n\u00fameros Coding time! Ejercicio 1 Escribe un programa que contenga las siguientes variables: nombre : tipo string y valor \"Michael Jordan\" edad : tipo integer y valor 50 media_puntos : tipo float y valor 28.5 activo : False El programa deber\u00e1 mostrar en pantalla todos los valores. Ejercicio 2 Escribe un programa que solicite el nombre, DNI y edad, lo almacene en 3 variables distintas y muestre por pantalla los valores introducidos. Ejercicio 3 Escribe un programa que genere un string compuesto por los primeros 3 caracteres y los \u00faltimos 3 caracteres de un string introducido por el usuario. Pista: tendr\u00e1s que utilizar la funci\u00f3n len() en la obtenci\u00f3n de los \u00faltimos 3 caracteres. Ejemplo 1: 'aprendiendo' Resultado 1: 'aprndo' Ejemplo 2: 'escribiendo c\u00f3digo' Resultado 2: 'escigo' Ejercicio 4 Escribe un programa que solicite al usuario dos n\u00fameros y una frase. El primer n\u00famero introducido se corresponder\u00e1 a la posici\u00f3n de inicio del substring que deber\u00e1 mostrar el programa por pantalla. El segundo n\u00famero indicar\u00e1 la longitud de dicho substring. Ejemplo 1: Posicion=4, Longitud=8, Frase='Desarrollar es mi nueva afici\u00f3n' Resultado 1: \"rrollar \" Ejemplo 2: Posicion=8, Longitud=11, Frase='Bienvenido a la clase de programaci\u00f3n' Resultado 2: \"do a la cla\" Ejercicio 5 Escribe un programa que solicite al usuario una frase. A continuaci\u00f3n le solicitar\u00e1 la letra que quiere reemplazar y por qu\u00e9 letra deber\u00e1 reemplazarse. Por \u00faltimo el programa mostrar\u00e1 el n\u00famero de veces que la letra est\u00e1 presente en la frase y el resultado final tras reemplazarla. Ejemplo: 'Desarrollar es mi nuevo pasatiempos', 'a','e' Resultado: 4 apariciones. 'Deserroller es mi nueve pesetiempos' Los n\u00fameros decimales se representan utilizando un punto decimal. Aunque en espa\u00f1ol utilizamos la coma decimal usaremos aqu\u00ed el punto decimal por ser el formato que se requiere en Python. \u21a9","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#valores","text":"Un valor es una de las cosas b\u00e1sicas que utiliza un programa, como una letra o un n\u00famero. Los valores que hemos visto hasta ahora han sido 1, 2, y \u201c\u00a1Hola, mundo!\u201d Esos valores pertenecen a tipos diferentes: 2 es un entero int , y \u201c \u00a1Hola, mundo! \u201d es una cadena string , que recibe ese nombre porque contiene una cadena de letras. Vosotros (y el int\u00e9rprete) podr\u00e9is identificar las cadenas porque van encerradas entre comillas.","title":"Valores"},{"location":"variables/#variables-y-tipos-de-datos","text":"Una de las caracter\u00edsticas m\u00e1s potentes de un lenguaje de programaci\u00f3n es la capacidad de manipular variables. Una variable es un nombre que se refiere a un valor. Una sentencia de asignaci\u00f3n crea variables nuevas y les da valores: En Python cada valor que exista, tiene un tipo de dato, pero no es necesario declarar el tipo de las variables. \u00bfComo funciona? Basado en cada asignaci\u00f3n a la variable, Python deduce el tipo que es y lo conserva internamente. Python proporciona muchos tipos de dato nativos. A continuaci\u00f3n se muestran los m\u00e1s importantes: Booleanos: Su valor es True o False. N\u00fameros: Pueden ser enteros (1, 2, 3,...), flotantes (1.1, 1.2, 1.3,...) 1 , fracciones (1/2, 1/3, 2/3,...), o incluso n\u00fameros complejos (ra\u00edz de -1). Cadenas : Son secuencias de caracteres Unicode, por ejemplo, un documento HTML. Como tipos de datos, destacaremos: Bytes y arrays de bytes: por ejemplo, un fichero de im\u00e1genes JPEG. Listas: Son secuencias ordenadas de valores. Tuplas: Son secuencias ordenadas e inmutables de valores. Conjuntos: Son \u201cbolsas\u201d de valores sin ordenar. Diccionarios: Son \u201cbolsas\u201d de sin ordenar de parejas clave-valor. Es posible buscar directamente por clave. En la imagen anterior ve\u00edamos que ten\u00edamos valores de tipo n\u00famero entero int , de tipo coma flotante float , as\u00ed como una cadena de tipo string str . El nombre de una variable se conoce como identificador , y deber\u00e1 cumplir las siguientes reglas: Comenzar con una letra o un gui\u00f3n bajo. El resto del nombre estar\u00e1 formado por letras, n\u00fameros o guiones bajos. Los nombres de las variables son case sensitive , es decir, no es lo mismo que una variable se llame resultado que RESULTADO . Existen una serie de palabras reservadas que no se pueden utilizar: Algunas de las recomendaciones respecto a los nombres de las variables est\u00e1n recogidas en la Gu\u00eda oficial de Estilos PEP8 de Python . Entre las m\u00e1s habituales encontramos las siguientes: Utilizar nombres descriptivos, en min\u00fasculas y separados por guiones bajos si fuese necesario: resultado , mi_variable , valor_anterior ,... Escribir las constantes en may\u00fasculas: MI_CONSTANTE , NUMERO_PI , ... Antes y despu\u00e9s del signo = , debe haber uno (y solo un) espacio en blanco. Nota No olvideis que lo que la gu\u00eda plantea son recomendaciones y no obligaciones. Por ejemplo, mientras PEP8 recomienda tabular el c\u00f3digo con 4 espacioes en blanco, la gu\u00eda particular de los desarrolladores de Google habla de 2 espacios en lugar de 4.","title":"Variables y tipos de datos"},{"location":"variables/#lectura-de-datos-en-python","text":"La funci\u00f3n input() permite introducir datos al usuario: >>> nombre = input () Leire >>> print ( nombre ) Leire Como se puede ver en el siguiente ejemplo, es posible tambi\u00e9n mostrar un mensaje al usuario, tal y como muestra el siguiente ejemplo. >>> nombre = input ( \"Escribe tu nombre: \" ) Escribe tu nombre : Leire >>> print ( nombre ) Leire","title":"Lectura de datos en Python"},{"location":"variables/#numeros","text":"Python soporta dos tipos de n\u00fameros: enteros (integer) y de punto flotante (float). ```python","title":"N\u00fameros"},{"location":"variables/#integer","text":"x = 5 print(x)","title":"integer"},{"location":"variables/#float","text":"y = 5.0 print(y)","title":"float"},{"location":"variables/#otra-forma-de-declarar-un-float","text":"z = float(5) print(z) Si tenemos dudas del valor de una variable, podemos mostrar su tipo utilizando la funci\u00f3n `type()`: ```python >>> x = 5.5 >>> type(x) <class 'float'>","title":"Otra forma de declarar un float"},{"location":"variables/#cadenas-de-texto-string","text":"Las cadenas de texto o strings se definen mediante comilla simple ( ' ' ) o doble comilla ( \" \" ): mi_nombre = 'Ane' print ( mi_nombre ) mi_nombre = \"Ane\" print ( mi_nombre ) La diferencia principal se encuentra en que las comillas dobles aportan mayor facilidad en textos que incluyan ap\u00f3strofes: mi_nombre = 'I \\' m John' print ( mi_nombre ) mi_nombre = \"I'm John\" print ( mi_nombre ) M\u00e1s informaci\u00f3n sobre strings y car\u00e1cteres especiales en: https://docs.python.org/3/tutorial/introduction.html#strings Para definir strings multi-l\u00ednea se utiliza la triples comillas ( \"\"\" ): frase = \"\"\" esto es una frase muy larga de m\u00e1s de una l\u00ednea ...\"\"\"","title":"Cadenas de texto (string)"},{"location":"variables/#concatenacion-de-strings","text":"Es posible unir dos strings con el operador + : >>> primera_palabra = 'Hola' >>> frase_completa = primera_palabra + ', mundo' >>> print ( frase_completa ) 'Hola, mundo' >>> segunda_palabra = 'mundo' >>> frase_completa = primera_palabra + ', ' + segunda_palabra >>> print ( frase_completa ) 'Hola, mundo' M\u00e9todo alternativo 1 : str.join(): El m\u00e9todo join() recibe como argumento el listado (de tipo List, Tuple, String, Dictionary y Set) de strings que se desean concatenar. Se invoca sobre el separador que se utilizar\u00e1 para unir las cadenas (el cual a su vez es un string tambi\u00e9n): >>> strings = [ 'do' , 're' , 'mi' ] >>> separador = ' - ' >>> separador . join ( strings ) 'do - re - mi' Para iterar un elemento detr\u00e1s del otro se introducir\u00e1 string vac\u00edo como separador: >>> strings = [ 'do' , 're' , 'mi' ] >>> '' . join ( strings ) 'doremi' M\u00e9todo alternativo 2 : str.format() : Python 3 introdujo una nueva forma para formatear strings, la cual sustituye a la anterior en la que se hace uso del operador % . Para ello se invoca el m\u00e9todo format() de un string: # Ordenado por defecto: frase = \"Meses: {} , {} y {} \" . format ( 'Enero' , 'Febrero' , 'Marzo' ) print ( frase ) # Especificar el orden indicando la posici\u00f3n: frase = \"Meses: {1} , {0} y {2} \" . format ( 'Enero' , 'Febrero' , 'Marzo' ) print ( frase ) # Especificar el orden mediante parejas clave-valor: frase = \"Meses: {ene} , {feb} y {mar} \" . format ( ene = 'Enero' , feb = 'Febrero' , mar = 'Marzo' ) print ( frase )","title":"Concatenaci\u00f3n de strings"},{"location":"variables/#cadenas-f-f-strings","text":"La versi\u00f3n 3.6 de Python trajo un gran avance a la hora de integrar variables o expreiones en cadenas de car\u00e1cteres. Se introdujeron las llamadas f-strings , una forma m\u00e1s c\u00f3moda y directa para insertar variables y expresiones en cadenas. Permiten introducir cualquier variable o expresi\u00f3n dentro de un string incluyendo la variable entre llaves { y } . Veamos un ejemplo: nombre = \"Nora\" edad = 22 saludo = f \"Me llamo { nombre } y tengo { edad } a\u00f1os.\" Para indicar que se trata de un f-string , este deber\u00e1 incluir la letra 'f' antes del comiendo de la cadena (antes de las comillas). A continuaci\u00f3n se muestra otro ejemplo en el que se introduce una expresi\u00f3n: a = 4 b = 3 print ( f \"La multiplicaci\u00f3n de { a } y { b } es igual a { a * b } \" )","title":"Cadenas 'f' (f-strings)"},{"location":"variables/#conversion-de-tipos","text":"A la hora de concatenar un string con otras variables como integer o float puede haber problemas: >>> edad = 25 >>> nota_media = 7.3 >>> print ( \"Tengo \" + edad + \" a\u00f1os y mi nota media es \" + nota_media + \".\" ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : can only concatenate str ( not \"int\" ) to str Mediante la funci\u00f3n str() podemos convertir un valor a string y evitar as\u00ed cualquier tipo de problema: >>> edad = 25 >>> nota_media = 7.3 >>> print ( \"Tengo \" + str ( edad ) + \" a\u00f1os y mi nota media es \" + str ( nota_media ) + \".\" ) Tengo 25 a\u00f1os y mi nota media es 7.3 . De igual manera es posible convertir a otros tipos con las funciones int() , float() and bool() .","title":"Conversi\u00f3n de tipos"},{"location":"variables/#metodos-en-cadenas-de-texto-string","text":"Es posible obtener un car\u00e1cter concreto de un string utilizando los corchetes [] y el \u00edndice del car\u00e1cter al que queremos acceder: frase = 'Aprendiendo a programar en Python' frase [ 0 ] # devuelve el primer caracter frase [ 1 ] # devuelve el segundo caracter frase [ - 1 ] # devuelve el primer caracter empezando por el final frase [ - 2 ] # # devuelve el segundo caracter empezando por el final Si queremos obtener un substring , utilizaremos la siguiente notaci\u00f3n: frase = 'Aprendiendo a programar en Python' mi_substring = frase [ 1 : 5 ] # devuelver\u00e1 los caracteres desde la posici\u00f3n 1 hasta la 5 (no incluye el 5) En caso de dejar la primera variable vac\u00eda, se considera la primera posici\u00f3n del string. Dejando la segunda variable vac\u00eda se considera la \u00faltima posici\u00f3n del string: >>> frase = 'Aprendiendo a programar en Python' >>> mi_substring = frase [: 5 ] >>> mi_substring 'Apren' >>> mi_substring = frase [ 4 :] >>> mi_substring 'ndiendo a programar en Python' Otros m\u00e9todos \u00fatiles de string: len ( str ) # devuelve la longitud del string str . upper () # convierte a may\u00fasculas str . lower () # convierte a min\u00fasculas str . title () # convierte a may\u00fasculas la primera letra de cada palabra str . count ( substring [, inicio , fin ]) # devuelve el n\u00famero de veces que aparece # el substring en el string. Opcionalmente se puede indicar el inicio y fin. str . find ( \u2018 d \u2019 ) # devuelve el \u00edndice de la primera aparici\u00f3n de 'd' # (devolver\u00e1 -1 si no lo encuentra) substr in str # devuelve True si el string contiene el substring str . replace ( old , new [, count ]) # reemplaza 'old' por 'new' un m\u00e1ximo de 'count' veces. str . isnumeric () # devuelve True si str contiene solamente n\u00fameros","title":"M\u00e9todos en cadenas de texto (string)"},{"location":"variables/#coding-time","text":"","title":"Coding time!"},{"location":"variables/#ejercicio-1","text":"Escribe un programa que contenga las siguientes variables: nombre : tipo string y valor \"Michael Jordan\" edad : tipo integer y valor 50 media_puntos : tipo float y valor 28.5 activo : False El programa deber\u00e1 mostrar en pantalla todos los valores.","title":"Ejercicio 1"},{"location":"variables/#ejercicio-2","text":"Escribe un programa que solicite el nombre, DNI y edad, lo almacene en 3 variables distintas y muestre por pantalla los valores introducidos.","title":"Ejercicio 2"},{"location":"variables/#ejercicio-3","text":"Escribe un programa que genere un string compuesto por los primeros 3 caracteres y los \u00faltimos 3 caracteres de un string introducido por el usuario. Pista: tendr\u00e1s que utilizar la funci\u00f3n len() en la obtenci\u00f3n de los \u00faltimos 3 caracteres. Ejemplo 1: 'aprendiendo' Resultado 1: 'aprndo' Ejemplo 2: 'escribiendo c\u00f3digo' Resultado 2: 'escigo'","title":"Ejercicio 3"},{"location":"variables/#ejercicio-4","text":"Escribe un programa que solicite al usuario dos n\u00fameros y una frase. El primer n\u00famero introducido se corresponder\u00e1 a la posici\u00f3n de inicio del substring que deber\u00e1 mostrar el programa por pantalla. El segundo n\u00famero indicar\u00e1 la longitud de dicho substring. Ejemplo 1: Posicion=4, Longitud=8, Frase='Desarrollar es mi nueva afici\u00f3n' Resultado 1: \"rrollar \" Ejemplo 2: Posicion=8, Longitud=11, Frase='Bienvenido a la clase de programaci\u00f3n' Resultado 2: \"do a la cla\"","title":"Ejercicio 4"},{"location":"variables/#ejercicio-5","text":"Escribe un programa que solicite al usuario una frase. A continuaci\u00f3n le solicitar\u00e1 la letra que quiere reemplazar y por qu\u00e9 letra deber\u00e1 reemplazarse. Por \u00faltimo el programa mostrar\u00e1 el n\u00famero de veces que la letra est\u00e1 presente en la frase y el resultado final tras reemplazarla. Ejemplo: 'Desarrollar es mi nuevo pasatiempos', 'a','e' Resultado: 4 apariciones. 'Deserroller es mi nueve pesetiempos' Los n\u00fameros decimales se representan utilizando un punto decimal. Aunque en espa\u00f1ol utilizamos la coma decimal usaremos aqu\u00ed el punto decimal por ser el formato que se requiere en Python. \u21a9","title":"Ejercicio 5"}]}